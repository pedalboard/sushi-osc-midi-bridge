//* gRPC definitions for external control of sushi
//
// @copyright 2018 - 2022 Modern Ancient Instruments Networked AB, dba Elk, Stockholm

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.4
// source: sushi_rpc.proto

package sushi_rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SystemController_GetSushiVersion_FullMethodName            = "/sushi_rpc.SystemController/GetSushiVersion"
	SystemController_GetBuildInfo_FullMethodName               = "/sushi_rpc.SystemController/GetBuildInfo"
	SystemController_GetInputAudioChannelCount_FullMethodName  = "/sushi_rpc.SystemController/GetInputAudioChannelCount"
	SystemController_GetOutputAudioChannelCount_FullMethodName = "/sushi_rpc.SystemController/GetOutputAudioChannelCount"
)

// SystemControllerClient is the client API for SystemController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemControllerClient interface {
	GetSushiVersion(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericStringValue, error)
	GetBuildInfo(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SushiBuildInfo, error)
	GetInputAudioChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetOutputAudioChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
}

type systemControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemControllerClient(cc grpc.ClientConnInterface) SystemControllerClient {
	return &systemControllerClient{cc}
}

func (c *systemControllerClient) GetSushiVersion(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, SystemController_GetSushiVersion_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemControllerClient) GetBuildInfo(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SushiBuildInfo, error) {
	out := new(SushiBuildInfo)
	err := c.cc.Invoke(ctx, SystemController_GetBuildInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemControllerClient) GetInputAudioChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, SystemController_GetInputAudioChannelCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemControllerClient) GetOutputAudioChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, SystemController_GetOutputAudioChannelCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemControllerServer is the server API for SystemController service.
// All implementations must embed UnimplementedSystemControllerServer
// for forward compatibility
type SystemControllerServer interface {
	GetSushiVersion(context.Context, *GenericVoidValue) (*GenericStringValue, error)
	GetBuildInfo(context.Context, *GenericVoidValue) (*SushiBuildInfo, error)
	GetInputAudioChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetOutputAudioChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	mustEmbedUnimplementedSystemControllerServer()
}

// UnimplementedSystemControllerServer must be embedded to have forward compatible implementations.
type UnimplementedSystemControllerServer struct {
}

func (UnimplementedSystemControllerServer) GetSushiVersion(context.Context, *GenericVoidValue) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSushiVersion not implemented")
}
func (UnimplementedSystemControllerServer) GetBuildInfo(context.Context, *GenericVoidValue) (*SushiBuildInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildInfo not implemented")
}
func (UnimplementedSystemControllerServer) GetInputAudioChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputAudioChannelCount not implemented")
}
func (UnimplementedSystemControllerServer) GetOutputAudioChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputAudioChannelCount not implemented")
}
func (UnimplementedSystemControllerServer) mustEmbedUnimplementedSystemControllerServer() {}

// UnsafeSystemControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemControllerServer will
// result in compilation errors.
type UnsafeSystemControllerServer interface {
	mustEmbedUnimplementedSystemControllerServer()
}

func RegisterSystemControllerServer(s grpc.ServiceRegistrar, srv SystemControllerServer) {
	s.RegisterService(&SystemController_ServiceDesc, srv)
}

func _SystemController_GetSushiVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemControllerServer).GetSushiVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemController_GetSushiVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemControllerServer).GetSushiVersion(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemController_GetBuildInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemControllerServer).GetBuildInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemController_GetBuildInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemControllerServer).GetBuildInfo(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemController_GetInputAudioChannelCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemControllerServer).GetInputAudioChannelCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemController_GetInputAudioChannelCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemControllerServer).GetInputAudioChannelCount(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemController_GetOutputAudioChannelCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemControllerServer).GetOutputAudioChannelCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemController_GetOutputAudioChannelCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemControllerServer).GetOutputAudioChannelCount(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemController_ServiceDesc is the grpc.ServiceDesc for SystemController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.SystemController",
	HandlerType: (*SystemControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSushiVersion",
			Handler:    _SystemController_GetSushiVersion_Handler,
		},
		{
			MethodName: "GetBuildInfo",
			Handler:    _SystemController_GetBuildInfo_Handler,
		},
		{
			MethodName: "GetInputAudioChannelCount",
			Handler:    _SystemController_GetInputAudioChannelCount_Handler,
		},
		{
			MethodName: "GetOutputAudioChannelCount",
			Handler:    _SystemController_GetOutputAudioChannelCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	TransportController_GetSamplerate_FullMethodName    = "/sushi_rpc.TransportController/GetSamplerate"
	TransportController_GetPlayingMode_FullMethodName   = "/sushi_rpc.TransportController/GetPlayingMode"
	TransportController_GetSyncMode_FullMethodName      = "/sushi_rpc.TransportController/GetSyncMode"
	TransportController_GetTimeSignature_FullMethodName = "/sushi_rpc.TransportController/GetTimeSignature"
	TransportController_GetTempo_FullMethodName         = "/sushi_rpc.TransportController/GetTempo"
	TransportController_SetTempo_FullMethodName         = "/sushi_rpc.TransportController/SetTempo"
	TransportController_SetPlayingMode_FullMethodName   = "/sushi_rpc.TransportController/SetPlayingMode"
	TransportController_SetSyncMode_FullMethodName      = "/sushi_rpc.TransportController/SetSyncMode"
	TransportController_SetTimeSignature_FullMethodName = "/sushi_rpc.TransportController/SetTimeSignature"
)

// TransportControllerClient is the client API for TransportController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransportControllerClient interface {
	GetSamplerate(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericFloatValue, error)
	GetPlayingMode(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*PlayingMode, error)
	GetSyncMode(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SyncMode, error)
	GetTimeSignature(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*TimeSignature, error)
	GetTempo(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericFloatValue, error)
	SetTempo(ctx context.Context, in *GenericFloatValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SetPlayingMode(ctx context.Context, in *PlayingMode, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SetSyncMode(ctx context.Context, in *SyncMode, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SetTimeSignature(ctx context.Context, in *TimeSignature, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type transportControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewTransportControllerClient(cc grpc.ClientConnInterface) TransportControllerClient {
	return &transportControllerClient{cc}
}

func (c *transportControllerClient) GetSamplerate(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericFloatValue, error) {
	out := new(GenericFloatValue)
	err := c.cc.Invoke(ctx, TransportController_GetSamplerate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) GetPlayingMode(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*PlayingMode, error) {
	out := new(PlayingMode)
	err := c.cc.Invoke(ctx, TransportController_GetPlayingMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) GetSyncMode(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SyncMode, error) {
	out := new(SyncMode)
	err := c.cc.Invoke(ctx, TransportController_GetSyncMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) GetTimeSignature(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*TimeSignature, error) {
	out := new(TimeSignature)
	err := c.cc.Invoke(ctx, TransportController_GetTimeSignature_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) GetTempo(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericFloatValue, error) {
	out := new(GenericFloatValue)
	err := c.cc.Invoke(ctx, TransportController_GetTempo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) SetTempo(ctx context.Context, in *GenericFloatValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TransportController_SetTempo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) SetPlayingMode(ctx context.Context, in *PlayingMode, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TransportController_SetPlayingMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) SetSyncMode(ctx context.Context, in *SyncMode, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TransportController_SetSyncMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transportControllerClient) SetTimeSignature(ctx context.Context, in *TimeSignature, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TransportController_SetTimeSignature_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransportControllerServer is the server API for TransportController service.
// All implementations must embed UnimplementedTransportControllerServer
// for forward compatibility
type TransportControllerServer interface {
	GetSamplerate(context.Context, *GenericVoidValue) (*GenericFloatValue, error)
	GetPlayingMode(context.Context, *GenericVoidValue) (*PlayingMode, error)
	GetSyncMode(context.Context, *GenericVoidValue) (*SyncMode, error)
	GetTimeSignature(context.Context, *GenericVoidValue) (*TimeSignature, error)
	GetTempo(context.Context, *GenericVoidValue) (*GenericFloatValue, error)
	SetTempo(context.Context, *GenericFloatValue) (*GenericVoidValue, error)
	SetPlayingMode(context.Context, *PlayingMode) (*GenericVoidValue, error)
	SetSyncMode(context.Context, *SyncMode) (*GenericVoidValue, error)
	SetTimeSignature(context.Context, *TimeSignature) (*GenericVoidValue, error)
	mustEmbedUnimplementedTransportControllerServer()
}

// UnimplementedTransportControllerServer must be embedded to have forward compatible implementations.
type UnimplementedTransportControllerServer struct {
}

func (UnimplementedTransportControllerServer) GetSamplerate(context.Context, *GenericVoidValue) (*GenericFloatValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSamplerate not implemented")
}
func (UnimplementedTransportControllerServer) GetPlayingMode(context.Context, *GenericVoidValue) (*PlayingMode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayingMode not implemented")
}
func (UnimplementedTransportControllerServer) GetSyncMode(context.Context, *GenericVoidValue) (*SyncMode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSyncMode not implemented")
}
func (UnimplementedTransportControllerServer) GetTimeSignature(context.Context, *GenericVoidValue) (*TimeSignature, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimeSignature not implemented")
}
func (UnimplementedTransportControllerServer) GetTempo(context.Context, *GenericVoidValue) (*GenericFloatValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTempo not implemented")
}
func (UnimplementedTransportControllerServer) SetTempo(context.Context, *GenericFloatValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTempo not implemented")
}
func (UnimplementedTransportControllerServer) SetPlayingMode(context.Context, *PlayingMode) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPlayingMode not implemented")
}
func (UnimplementedTransportControllerServer) SetSyncMode(context.Context, *SyncMode) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSyncMode not implemented")
}
func (UnimplementedTransportControllerServer) SetTimeSignature(context.Context, *TimeSignature) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeSignature not implemented")
}
func (UnimplementedTransportControllerServer) mustEmbedUnimplementedTransportControllerServer() {}

// UnsafeTransportControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransportControllerServer will
// result in compilation errors.
type UnsafeTransportControllerServer interface {
	mustEmbedUnimplementedTransportControllerServer()
}

func RegisterTransportControllerServer(s grpc.ServiceRegistrar, srv TransportControllerServer) {
	s.RegisterService(&TransportController_ServiceDesc, srv)
}

func _TransportController_GetSamplerate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).GetSamplerate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_GetSamplerate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).GetSamplerate(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_GetPlayingMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).GetPlayingMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_GetPlayingMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).GetPlayingMode(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_GetSyncMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).GetSyncMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_GetSyncMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).GetSyncMode(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_GetTimeSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).GetTimeSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_GetTimeSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).GetTimeSignature(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_GetTempo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).GetTempo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_GetTempo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).GetTempo(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_SetTempo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericFloatValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).SetTempo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_SetTempo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).SetTempo(ctx, req.(*GenericFloatValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_SetPlayingMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayingMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).SetPlayingMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_SetPlayingMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).SetPlayingMode(ctx, req.(*PlayingMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_SetSyncMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).SetSyncMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_SetSyncMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).SetSyncMode(ctx, req.(*SyncMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransportController_SetTimeSignature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeSignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransportControllerServer).SetTimeSignature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransportController_SetTimeSignature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransportControllerServer).SetTimeSignature(ctx, req.(*TimeSignature))
	}
	return interceptor(ctx, in, info, handler)
}

// TransportController_ServiceDesc is the grpc.ServiceDesc for TransportController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransportController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.TransportController",
	HandlerType: (*TransportControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSamplerate",
			Handler:    _TransportController_GetSamplerate_Handler,
		},
		{
			MethodName: "GetPlayingMode",
			Handler:    _TransportController_GetPlayingMode_Handler,
		},
		{
			MethodName: "GetSyncMode",
			Handler:    _TransportController_GetSyncMode_Handler,
		},
		{
			MethodName: "GetTimeSignature",
			Handler:    _TransportController_GetTimeSignature_Handler,
		},
		{
			MethodName: "GetTempo",
			Handler:    _TransportController_GetTempo_Handler,
		},
		{
			MethodName: "SetTempo",
			Handler:    _TransportController_SetTempo_Handler,
		},
		{
			MethodName: "SetPlayingMode",
			Handler:    _TransportController_SetPlayingMode_Handler,
		},
		{
			MethodName: "SetSyncMode",
			Handler:    _TransportController_SetSyncMode_Handler,
		},
		{
			MethodName: "SetTimeSignature",
			Handler:    _TransportController_SetTimeSignature_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	TimingController_GetTimingsEnabled_FullMethodName     = "/sushi_rpc.TimingController/GetTimingsEnabled"
	TimingController_SetTimingsEnabled_FullMethodName     = "/sushi_rpc.TimingController/SetTimingsEnabled"
	TimingController_GetEngineTimings_FullMethodName      = "/sushi_rpc.TimingController/GetEngineTimings"
	TimingController_GetTrackTimings_FullMethodName       = "/sushi_rpc.TimingController/GetTrackTimings"
	TimingController_GetProcessorTimings_FullMethodName   = "/sushi_rpc.TimingController/GetProcessorTimings"
	TimingController_ResetAllTimings_FullMethodName       = "/sushi_rpc.TimingController/ResetAllTimings"
	TimingController_ResetTrackTimings_FullMethodName     = "/sushi_rpc.TimingController/ResetTrackTimings"
	TimingController_ResetProcessorTimings_FullMethodName = "/sushi_rpc.TimingController/ResetProcessorTimings"
)

// TimingControllerClient is the client API for TimingController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimingControllerClient interface {
	GetTimingsEnabled(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericBoolValue, error)
	SetTimingsEnabled(ctx context.Context, in *GenericBoolValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
	GetEngineTimings(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CpuTimings, error)
	GetTrackTimings(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*CpuTimings, error)
	GetProcessorTimings(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CpuTimings, error)
	ResetAllTimings(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ResetTrackTimings(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ResetProcessorTimings(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type timingControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewTimingControllerClient(cc grpc.ClientConnInterface) TimingControllerClient {
	return &timingControllerClient{cc}
}

func (c *timingControllerClient) GetTimingsEnabled(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericBoolValue, error) {
	out := new(GenericBoolValue)
	err := c.cc.Invoke(ctx, TimingController_GetTimingsEnabled_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) SetTimingsEnabled(ctx context.Context, in *GenericBoolValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TimingController_SetTimingsEnabled_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) GetEngineTimings(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CpuTimings, error) {
	out := new(CpuTimings)
	err := c.cc.Invoke(ctx, TimingController_GetEngineTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) GetTrackTimings(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*CpuTimings, error) {
	out := new(CpuTimings)
	err := c.cc.Invoke(ctx, TimingController_GetTrackTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) GetProcessorTimings(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CpuTimings, error) {
	out := new(CpuTimings)
	err := c.cc.Invoke(ctx, TimingController_GetProcessorTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) ResetAllTimings(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TimingController_ResetAllTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) ResetTrackTimings(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TimingController_ResetTrackTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timingControllerClient) ResetProcessorTimings(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, TimingController_ResetProcessorTimings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimingControllerServer is the server API for TimingController service.
// All implementations must embed UnimplementedTimingControllerServer
// for forward compatibility
type TimingControllerServer interface {
	GetTimingsEnabled(context.Context, *GenericVoidValue) (*GenericBoolValue, error)
	SetTimingsEnabled(context.Context, *GenericBoolValue) (*GenericVoidValue, error)
	GetEngineTimings(context.Context, *GenericVoidValue) (*CpuTimings, error)
	GetTrackTimings(context.Context, *TrackIdentifier) (*CpuTimings, error)
	GetProcessorTimings(context.Context, *ProcessorIdentifier) (*CpuTimings, error)
	ResetAllTimings(context.Context, *GenericVoidValue) (*GenericVoidValue, error)
	ResetTrackTimings(context.Context, *TrackIdentifier) (*GenericVoidValue, error)
	ResetProcessorTimings(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	mustEmbedUnimplementedTimingControllerServer()
}

// UnimplementedTimingControllerServer must be embedded to have forward compatible implementations.
type UnimplementedTimingControllerServer struct {
}

func (UnimplementedTimingControllerServer) GetTimingsEnabled(context.Context, *GenericVoidValue) (*GenericBoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimingsEnabled not implemented")
}
func (UnimplementedTimingControllerServer) SetTimingsEnabled(context.Context, *GenericBoolValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimingsEnabled not implemented")
}
func (UnimplementedTimingControllerServer) GetEngineTimings(context.Context, *GenericVoidValue) (*CpuTimings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEngineTimings not implemented")
}
func (UnimplementedTimingControllerServer) GetTrackTimings(context.Context, *TrackIdentifier) (*CpuTimings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackTimings not implemented")
}
func (UnimplementedTimingControllerServer) GetProcessorTimings(context.Context, *ProcessorIdentifier) (*CpuTimings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorTimings not implemented")
}
func (UnimplementedTimingControllerServer) ResetAllTimings(context.Context, *GenericVoidValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAllTimings not implemented")
}
func (UnimplementedTimingControllerServer) ResetTrackTimings(context.Context, *TrackIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetTrackTimings not implemented")
}
func (UnimplementedTimingControllerServer) ResetProcessorTimings(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetProcessorTimings not implemented")
}
func (UnimplementedTimingControllerServer) mustEmbedUnimplementedTimingControllerServer() {}

// UnsafeTimingControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimingControllerServer will
// result in compilation errors.
type UnsafeTimingControllerServer interface {
	mustEmbedUnimplementedTimingControllerServer()
}

func RegisterTimingControllerServer(s grpc.ServiceRegistrar, srv TimingControllerServer) {
	s.RegisterService(&TimingController_ServiceDesc, srv)
}

func _TimingController_GetTimingsEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).GetTimingsEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_GetTimingsEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).GetTimingsEnabled(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_SetTimingsEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericBoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).SetTimingsEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_SetTimingsEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).SetTimingsEnabled(ctx, req.(*GenericBoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_GetEngineTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).GetEngineTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_GetEngineTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).GetEngineTimings(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_GetTrackTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).GetTrackTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_GetTrackTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).GetTrackTimings(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_GetProcessorTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).GetProcessorTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_GetProcessorTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).GetProcessorTimings(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_ResetAllTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).ResetAllTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_ResetAllTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).ResetAllTimings(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_ResetTrackTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).ResetTrackTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_ResetTrackTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).ResetTrackTimings(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimingController_ResetProcessorTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimingControllerServer).ResetProcessorTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimingController_ResetProcessorTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimingControllerServer).ResetProcessorTimings(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// TimingController_ServiceDesc is the grpc.ServiceDesc for TimingController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimingController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.TimingController",
	HandlerType: (*TimingControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTimingsEnabled",
			Handler:    _TimingController_GetTimingsEnabled_Handler,
		},
		{
			MethodName: "SetTimingsEnabled",
			Handler:    _TimingController_SetTimingsEnabled_Handler,
		},
		{
			MethodName: "GetEngineTimings",
			Handler:    _TimingController_GetEngineTimings_Handler,
		},
		{
			MethodName: "GetTrackTimings",
			Handler:    _TimingController_GetTrackTimings_Handler,
		},
		{
			MethodName: "GetProcessorTimings",
			Handler:    _TimingController_GetProcessorTimings_Handler,
		},
		{
			MethodName: "ResetAllTimings",
			Handler:    _TimingController_ResetAllTimings_Handler,
		},
		{
			MethodName: "ResetTrackTimings",
			Handler:    _TimingController_ResetTrackTimings_Handler,
		},
		{
			MethodName: "ResetProcessorTimings",
			Handler:    _TimingController_ResetProcessorTimings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	KeyboardController_SendNoteOn_FullMethodName         = "/sushi_rpc.KeyboardController/SendNoteOn"
	KeyboardController_SendNoteOff_FullMethodName        = "/sushi_rpc.KeyboardController/SendNoteOff"
	KeyboardController_SendNoteAftertouch_FullMethodName = "/sushi_rpc.KeyboardController/SendNoteAftertouch"
	KeyboardController_SendAftertouch_FullMethodName     = "/sushi_rpc.KeyboardController/SendAftertouch"
	KeyboardController_SendPitchBend_FullMethodName      = "/sushi_rpc.KeyboardController/SendPitchBend"
	KeyboardController_SendModulation_FullMethodName     = "/sushi_rpc.KeyboardController/SendModulation"
)

// KeyboardControllerClient is the client API for KeyboardController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeyboardControllerClient interface {
	SendNoteOn(ctx context.Context, in *NoteOnRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SendNoteOff(ctx context.Context, in *NoteOffRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SendNoteAftertouch(ctx context.Context, in *NoteAftertouchRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SendAftertouch(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SendPitchBend(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SendModulation(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type keyboardControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewKeyboardControllerClient(cc grpc.ClientConnInterface) KeyboardControllerClient {
	return &keyboardControllerClient{cc}
}

func (c *keyboardControllerClient) SendNoteOn(ctx context.Context, in *NoteOnRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendNoteOn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyboardControllerClient) SendNoteOff(ctx context.Context, in *NoteOffRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendNoteOff_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyboardControllerClient) SendNoteAftertouch(ctx context.Context, in *NoteAftertouchRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendNoteAftertouch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyboardControllerClient) SendAftertouch(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendAftertouch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyboardControllerClient) SendPitchBend(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendPitchBend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyboardControllerClient) SendModulation(ctx context.Context, in *NoteModulationRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, KeyboardController_SendModulation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeyboardControllerServer is the server API for KeyboardController service.
// All implementations must embed UnimplementedKeyboardControllerServer
// for forward compatibility
type KeyboardControllerServer interface {
	SendNoteOn(context.Context, *NoteOnRequest) (*GenericVoidValue, error)
	SendNoteOff(context.Context, *NoteOffRequest) (*GenericVoidValue, error)
	SendNoteAftertouch(context.Context, *NoteAftertouchRequest) (*GenericVoidValue, error)
	SendAftertouch(context.Context, *NoteModulationRequest) (*GenericVoidValue, error)
	SendPitchBend(context.Context, *NoteModulationRequest) (*GenericVoidValue, error)
	SendModulation(context.Context, *NoteModulationRequest) (*GenericVoidValue, error)
	mustEmbedUnimplementedKeyboardControllerServer()
}

// UnimplementedKeyboardControllerServer must be embedded to have forward compatible implementations.
type UnimplementedKeyboardControllerServer struct {
}

func (UnimplementedKeyboardControllerServer) SendNoteOn(context.Context, *NoteOnRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNoteOn not implemented")
}
func (UnimplementedKeyboardControllerServer) SendNoteOff(context.Context, *NoteOffRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNoteOff not implemented")
}
func (UnimplementedKeyboardControllerServer) SendNoteAftertouch(context.Context, *NoteAftertouchRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNoteAftertouch not implemented")
}
func (UnimplementedKeyboardControllerServer) SendAftertouch(context.Context, *NoteModulationRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendAftertouch not implemented")
}
func (UnimplementedKeyboardControllerServer) SendPitchBend(context.Context, *NoteModulationRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPitchBend not implemented")
}
func (UnimplementedKeyboardControllerServer) SendModulation(context.Context, *NoteModulationRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendModulation not implemented")
}
func (UnimplementedKeyboardControllerServer) mustEmbedUnimplementedKeyboardControllerServer() {}

// UnsafeKeyboardControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeyboardControllerServer will
// result in compilation errors.
type UnsafeKeyboardControllerServer interface {
	mustEmbedUnimplementedKeyboardControllerServer()
}

func RegisterKeyboardControllerServer(s grpc.ServiceRegistrar, srv KeyboardControllerServer) {
	s.RegisterService(&KeyboardController_ServiceDesc, srv)
}

func _KeyboardController_SendNoteOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendNoteOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendNoteOn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendNoteOn(ctx, req.(*NoteOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyboardController_SendNoteOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteOffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendNoteOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendNoteOff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendNoteOff(ctx, req.(*NoteOffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyboardController_SendNoteAftertouch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteAftertouchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendNoteAftertouch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendNoteAftertouch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendNoteAftertouch(ctx, req.(*NoteAftertouchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyboardController_SendAftertouch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteModulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendAftertouch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendAftertouch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendAftertouch(ctx, req.(*NoteModulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyboardController_SendPitchBend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteModulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendPitchBend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendPitchBend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendPitchBend(ctx, req.(*NoteModulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeyboardController_SendModulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteModulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeyboardControllerServer).SendModulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeyboardController_SendModulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeyboardControllerServer).SendModulation(ctx, req.(*NoteModulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeyboardController_ServiceDesc is the grpc.ServiceDesc for KeyboardController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeyboardController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.KeyboardController",
	HandlerType: (*KeyboardControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNoteOn",
			Handler:    _KeyboardController_SendNoteOn_Handler,
		},
		{
			MethodName: "SendNoteOff",
			Handler:    _KeyboardController_SendNoteOff_Handler,
		},
		{
			MethodName: "SendNoteAftertouch",
			Handler:    _KeyboardController_SendNoteAftertouch_Handler,
		},
		{
			MethodName: "SendAftertouch",
			Handler:    _KeyboardController_SendAftertouch_Handler,
		},
		{
			MethodName: "SendPitchBend",
			Handler:    _KeyboardController_SendPitchBend_Handler,
		},
		{
			MethodName: "SendModulation",
			Handler:    _KeyboardController_SendModulation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	AudioGraphController_GetAllProcessors_FullMethodName         = "/sushi_rpc.AudioGraphController/GetAllProcessors"
	AudioGraphController_GetAllTracks_FullMethodName             = "/sushi_rpc.AudioGraphController/GetAllTracks"
	AudioGraphController_GetTrackId_FullMethodName               = "/sushi_rpc.AudioGraphController/GetTrackId"
	AudioGraphController_GetTrackInfo_FullMethodName             = "/sushi_rpc.AudioGraphController/GetTrackInfo"
	AudioGraphController_GetTrackProcessors_FullMethodName       = "/sushi_rpc.AudioGraphController/GetTrackProcessors"
	AudioGraphController_GetProcessorId_FullMethodName           = "/sushi_rpc.AudioGraphController/GetProcessorId"
	AudioGraphController_GetProcessorInfo_FullMethodName         = "/sushi_rpc.AudioGraphController/GetProcessorInfo"
	AudioGraphController_GetProcessorBypassState_FullMethodName  = "/sushi_rpc.AudioGraphController/GetProcessorBypassState"
	AudioGraphController_GetProcessorState_FullMethodName        = "/sushi_rpc.AudioGraphController/GetProcessorState"
	AudioGraphController_SetProcessorBypassState_FullMethodName  = "/sushi_rpc.AudioGraphController/SetProcessorBypassState"
	AudioGraphController_SetProcessorState_FullMethodName        = "/sushi_rpc.AudioGraphController/SetProcessorState"
	AudioGraphController_CreateTrack_FullMethodName              = "/sushi_rpc.AudioGraphController/CreateTrack"
	AudioGraphController_CreateMultibusTrack_FullMethodName      = "/sushi_rpc.AudioGraphController/CreateMultibusTrack"
	AudioGraphController_CreatePreTrack_FullMethodName           = "/sushi_rpc.AudioGraphController/CreatePreTrack"
	AudioGraphController_CreatePostTrack_FullMethodName          = "/sushi_rpc.AudioGraphController/CreatePostTrack"
	AudioGraphController_CreateProcessorOnTrack_FullMethodName   = "/sushi_rpc.AudioGraphController/CreateProcessorOnTrack"
	AudioGraphController_MoveProcessorOnTrack_FullMethodName     = "/sushi_rpc.AudioGraphController/MoveProcessorOnTrack"
	AudioGraphController_DeleteProcessorFromTrack_FullMethodName = "/sushi_rpc.AudioGraphController/DeleteProcessorFromTrack"
	AudioGraphController_DeleteTrack_FullMethodName              = "/sushi_rpc.AudioGraphController/DeleteTrack"
)

// AudioGraphControllerClient is the client API for AudioGraphController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AudioGraphControllerClient interface {
	GetAllProcessors(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*ProcessorInfoList, error)
	GetAllTracks(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*TrackInfoList, error)
	GetTrackId(ctx context.Context, in *GenericStringValue, opts ...grpc.CallOption) (*TrackIdentifier, error)
	GetTrackInfo(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*TrackInfo, error)
	GetTrackProcessors(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*ProcessorInfoList, error)
	GetProcessorId(ctx context.Context, in *GenericStringValue, opts ...grpc.CallOption) (*ProcessorIdentifier, error)
	GetProcessorInfo(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProcessorInfo, error)
	GetProcessorBypassState(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericBoolValue, error)
	GetProcessorState(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProcessorState, error)
	SetProcessorBypassState(ctx context.Context, in *ProcessorBypassStateSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	SetProcessorState(ctx context.Context, in *ProcessorStateSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	CreateTrack(ctx context.Context, in *CreateTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	CreateMultibusTrack(ctx context.Context, in *CreateMultibusTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	CreatePreTrack(ctx context.Context, in *CreatePreTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	CreatePostTrack(ctx context.Context, in *CreatePostTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	CreateProcessorOnTrack(ctx context.Context, in *CreateProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	MoveProcessorOnTrack(ctx context.Context, in *MoveProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DeleteProcessorFromTrack(ctx context.Context, in *DeleteProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DeleteTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type audioGraphControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewAudioGraphControllerClient(cc grpc.ClientConnInterface) AudioGraphControllerClient {
	return &audioGraphControllerClient{cc}
}

func (c *audioGraphControllerClient) GetAllProcessors(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*ProcessorInfoList, error) {
	out := new(ProcessorInfoList)
	err := c.cc.Invoke(ctx, AudioGraphController_GetAllProcessors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetAllTracks(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*TrackInfoList, error) {
	out := new(TrackInfoList)
	err := c.cc.Invoke(ctx, AudioGraphController_GetAllTracks_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetTrackId(ctx context.Context, in *GenericStringValue, opts ...grpc.CallOption) (*TrackIdentifier, error) {
	out := new(TrackIdentifier)
	err := c.cc.Invoke(ctx, AudioGraphController_GetTrackId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetTrackInfo(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*TrackInfo, error) {
	out := new(TrackInfo)
	err := c.cc.Invoke(ctx, AudioGraphController_GetTrackInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetTrackProcessors(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*ProcessorInfoList, error) {
	out := new(ProcessorInfoList)
	err := c.cc.Invoke(ctx, AudioGraphController_GetTrackProcessors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetProcessorId(ctx context.Context, in *GenericStringValue, opts ...grpc.CallOption) (*ProcessorIdentifier, error) {
	out := new(ProcessorIdentifier)
	err := c.cc.Invoke(ctx, AudioGraphController_GetProcessorId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetProcessorInfo(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProcessorInfo, error) {
	out := new(ProcessorInfo)
	err := c.cc.Invoke(ctx, AudioGraphController_GetProcessorInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetProcessorBypassState(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericBoolValue, error) {
	out := new(GenericBoolValue)
	err := c.cc.Invoke(ctx, AudioGraphController_GetProcessorBypassState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) GetProcessorState(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProcessorState, error) {
	out := new(ProcessorState)
	err := c.cc.Invoke(ctx, AudioGraphController_GetProcessorState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) SetProcessorBypassState(ctx context.Context, in *ProcessorBypassStateSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_SetProcessorBypassState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) SetProcessorState(ctx context.Context, in *ProcessorStateSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_SetProcessorState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) CreateTrack(ctx context.Context, in *CreateTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_CreateTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) CreateMultibusTrack(ctx context.Context, in *CreateMultibusTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_CreateMultibusTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) CreatePreTrack(ctx context.Context, in *CreatePreTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_CreatePreTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) CreatePostTrack(ctx context.Context, in *CreatePostTrackRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_CreatePostTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) CreateProcessorOnTrack(ctx context.Context, in *CreateProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_CreateProcessorOnTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) MoveProcessorOnTrack(ctx context.Context, in *MoveProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_MoveProcessorOnTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) DeleteProcessorFromTrack(ctx context.Context, in *DeleteProcessorRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_DeleteProcessorFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioGraphControllerClient) DeleteTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioGraphController_DeleteTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AudioGraphControllerServer is the server API for AudioGraphController service.
// All implementations must embed UnimplementedAudioGraphControllerServer
// for forward compatibility
type AudioGraphControllerServer interface {
	GetAllProcessors(context.Context, *GenericVoidValue) (*ProcessorInfoList, error)
	GetAllTracks(context.Context, *GenericVoidValue) (*TrackInfoList, error)
	GetTrackId(context.Context, *GenericStringValue) (*TrackIdentifier, error)
	GetTrackInfo(context.Context, *TrackIdentifier) (*TrackInfo, error)
	GetTrackProcessors(context.Context, *TrackIdentifier) (*ProcessorInfoList, error)
	GetProcessorId(context.Context, *GenericStringValue) (*ProcessorIdentifier, error)
	GetProcessorInfo(context.Context, *ProcessorIdentifier) (*ProcessorInfo, error)
	GetProcessorBypassState(context.Context, *ProcessorIdentifier) (*GenericBoolValue, error)
	GetProcessorState(context.Context, *ProcessorIdentifier) (*ProcessorState, error)
	SetProcessorBypassState(context.Context, *ProcessorBypassStateSetRequest) (*GenericVoidValue, error)
	SetProcessorState(context.Context, *ProcessorStateSetRequest) (*GenericVoidValue, error)
	CreateTrack(context.Context, *CreateTrackRequest) (*GenericVoidValue, error)
	CreateMultibusTrack(context.Context, *CreateMultibusTrackRequest) (*GenericVoidValue, error)
	CreatePreTrack(context.Context, *CreatePreTrackRequest) (*GenericVoidValue, error)
	CreatePostTrack(context.Context, *CreatePostTrackRequest) (*GenericVoidValue, error)
	CreateProcessorOnTrack(context.Context, *CreateProcessorRequest) (*GenericVoidValue, error)
	MoveProcessorOnTrack(context.Context, *MoveProcessorRequest) (*GenericVoidValue, error)
	DeleteProcessorFromTrack(context.Context, *DeleteProcessorRequest) (*GenericVoidValue, error)
	DeleteTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error)
	mustEmbedUnimplementedAudioGraphControllerServer()
}

// UnimplementedAudioGraphControllerServer must be embedded to have forward compatible implementations.
type UnimplementedAudioGraphControllerServer struct {
}

func (UnimplementedAudioGraphControllerServer) GetAllProcessors(context.Context, *GenericVoidValue) (*ProcessorInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProcessors not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetAllTracks(context.Context, *GenericVoidValue) (*TrackInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTracks not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetTrackId(context.Context, *GenericStringValue) (*TrackIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackId not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetTrackInfo(context.Context, *TrackIdentifier) (*TrackInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackInfo not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetTrackProcessors(context.Context, *TrackIdentifier) (*ProcessorInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackProcessors not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetProcessorId(context.Context, *GenericStringValue) (*ProcessorIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorId not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetProcessorInfo(context.Context, *ProcessorIdentifier) (*ProcessorInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorInfo not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetProcessorBypassState(context.Context, *ProcessorIdentifier) (*GenericBoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorBypassState not implemented")
}
func (UnimplementedAudioGraphControllerServer) GetProcessorState(context.Context, *ProcessorIdentifier) (*ProcessorState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorState not implemented")
}
func (UnimplementedAudioGraphControllerServer) SetProcessorBypassState(context.Context, *ProcessorBypassStateSetRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessorBypassState not implemented")
}
func (UnimplementedAudioGraphControllerServer) SetProcessorState(context.Context, *ProcessorStateSetRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessorState not implemented")
}
func (UnimplementedAudioGraphControllerServer) CreateTrack(context.Context, *CreateTrackRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) CreateMultibusTrack(context.Context, *CreateMultibusTrackRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultibusTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) CreatePreTrack(context.Context, *CreatePreTrackRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePreTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) CreatePostTrack(context.Context, *CreatePostTrackRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePostTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) CreateProcessorOnTrack(context.Context, *CreateProcessorRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcessorOnTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) MoveProcessorOnTrack(context.Context, *MoveProcessorRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveProcessorOnTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) DeleteProcessorFromTrack(context.Context, *DeleteProcessorRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProcessorFromTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) DeleteTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrack not implemented")
}
func (UnimplementedAudioGraphControllerServer) mustEmbedUnimplementedAudioGraphControllerServer() {}

// UnsafeAudioGraphControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AudioGraphControllerServer will
// result in compilation errors.
type UnsafeAudioGraphControllerServer interface {
	mustEmbedUnimplementedAudioGraphControllerServer()
}

func RegisterAudioGraphControllerServer(s grpc.ServiceRegistrar, srv AudioGraphControllerServer) {
	s.RegisterService(&AudioGraphController_ServiceDesc, srv)
}

func _AudioGraphController_GetAllProcessors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetAllProcessors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetAllProcessors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetAllProcessors(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetAllTracks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetAllTracks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetAllTracks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetAllTracks(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetTrackId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericStringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetTrackId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetTrackId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetTrackId(ctx, req.(*GenericStringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetTrackInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetTrackInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetTrackInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetTrackInfo(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetTrackProcessors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetTrackProcessors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetTrackProcessors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetTrackProcessors(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetProcessorId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericStringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetProcessorId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetProcessorId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetProcessorId(ctx, req.(*GenericStringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetProcessorInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetProcessorInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetProcessorInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetProcessorInfo(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetProcessorBypassState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetProcessorBypassState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetProcessorBypassState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetProcessorBypassState(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_GetProcessorState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).GetProcessorState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_GetProcessorState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).GetProcessorState(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_SetProcessorBypassState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorBypassStateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).SetProcessorBypassState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_SetProcessorBypassState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).SetProcessorBypassState(ctx, req.(*ProcessorBypassStateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_SetProcessorState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorStateSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).SetProcessorState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_SetProcessorState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).SetProcessorState(ctx, req.(*ProcessorStateSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_CreateTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).CreateTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_CreateTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).CreateTrack(ctx, req.(*CreateTrackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_CreateMultibusTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMultibusTrackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).CreateMultibusTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_CreateMultibusTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).CreateMultibusTrack(ctx, req.(*CreateMultibusTrackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_CreatePreTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePreTrackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).CreatePreTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_CreatePreTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).CreatePreTrack(ctx, req.(*CreatePreTrackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_CreatePostTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePostTrackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).CreatePostTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_CreatePostTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).CreatePostTrack(ctx, req.(*CreatePostTrackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_CreateProcessorOnTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).CreateProcessorOnTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_CreateProcessorOnTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).CreateProcessorOnTrack(ctx, req.(*CreateProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_MoveProcessorOnTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).MoveProcessorOnTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_MoveProcessorOnTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).MoveProcessorOnTrack(ctx, req.(*MoveProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_DeleteProcessorFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProcessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).DeleteProcessorFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_DeleteProcessorFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).DeleteProcessorFromTrack(ctx, req.(*DeleteProcessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioGraphController_DeleteTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioGraphControllerServer).DeleteTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioGraphController_DeleteTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioGraphControllerServer).DeleteTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// AudioGraphController_ServiceDesc is the grpc.ServiceDesc for AudioGraphController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AudioGraphController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.AudioGraphController",
	HandlerType: (*AudioGraphControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllProcessors",
			Handler:    _AudioGraphController_GetAllProcessors_Handler,
		},
		{
			MethodName: "GetAllTracks",
			Handler:    _AudioGraphController_GetAllTracks_Handler,
		},
		{
			MethodName: "GetTrackId",
			Handler:    _AudioGraphController_GetTrackId_Handler,
		},
		{
			MethodName: "GetTrackInfo",
			Handler:    _AudioGraphController_GetTrackInfo_Handler,
		},
		{
			MethodName: "GetTrackProcessors",
			Handler:    _AudioGraphController_GetTrackProcessors_Handler,
		},
		{
			MethodName: "GetProcessorId",
			Handler:    _AudioGraphController_GetProcessorId_Handler,
		},
		{
			MethodName: "GetProcessorInfo",
			Handler:    _AudioGraphController_GetProcessorInfo_Handler,
		},
		{
			MethodName: "GetProcessorBypassState",
			Handler:    _AudioGraphController_GetProcessorBypassState_Handler,
		},
		{
			MethodName: "GetProcessorState",
			Handler:    _AudioGraphController_GetProcessorState_Handler,
		},
		{
			MethodName: "SetProcessorBypassState",
			Handler:    _AudioGraphController_SetProcessorBypassState_Handler,
		},
		{
			MethodName: "SetProcessorState",
			Handler:    _AudioGraphController_SetProcessorState_Handler,
		},
		{
			MethodName: "CreateTrack",
			Handler:    _AudioGraphController_CreateTrack_Handler,
		},
		{
			MethodName: "CreateMultibusTrack",
			Handler:    _AudioGraphController_CreateMultibusTrack_Handler,
		},
		{
			MethodName: "CreatePreTrack",
			Handler:    _AudioGraphController_CreatePreTrack_Handler,
		},
		{
			MethodName: "CreatePostTrack",
			Handler:    _AudioGraphController_CreatePostTrack_Handler,
		},
		{
			MethodName: "CreateProcessorOnTrack",
			Handler:    _AudioGraphController_CreateProcessorOnTrack_Handler,
		},
		{
			MethodName: "MoveProcessorOnTrack",
			Handler:    _AudioGraphController_MoveProcessorOnTrack_Handler,
		},
		{
			MethodName: "DeleteProcessorFromTrack",
			Handler:    _AudioGraphController_DeleteProcessorFromTrack_Handler,
		},
		{
			MethodName: "DeleteTrack",
			Handler:    _AudioGraphController_DeleteTrack_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	ProgramController_GetProcessorCurrentProgram_FullMethodName     = "/sushi_rpc.ProgramController/GetProcessorCurrentProgram"
	ProgramController_GetProcessorCurrentProgramName_FullMethodName = "/sushi_rpc.ProgramController/GetProcessorCurrentProgramName"
	ProgramController_GetProcessorProgramName_FullMethodName        = "/sushi_rpc.ProgramController/GetProcessorProgramName"
	ProgramController_GetProcessorPrograms_FullMethodName           = "/sushi_rpc.ProgramController/GetProcessorPrograms"
	ProgramController_SetProcessorProgram_FullMethodName            = "/sushi_rpc.ProgramController/SetProcessorProgram"
)

// ProgramControllerClient is the client API for ProgramController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProgramControllerClient interface {
	GetProcessorCurrentProgram(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProgramIdentifier, error)
	GetProcessorCurrentProgramName(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error)
	GetProcessorProgramName(ctx context.Context, in *ProcessorProgramIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error)
	GetProcessorPrograms(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProgramInfoList, error)
	SetProcessorProgram(ctx context.Context, in *ProcessorProgramSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type programControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewProgramControllerClient(cc grpc.ClientConnInterface) ProgramControllerClient {
	return &programControllerClient{cc}
}

func (c *programControllerClient) GetProcessorCurrentProgram(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProgramIdentifier, error) {
	out := new(ProgramIdentifier)
	err := c.cc.Invoke(ctx, ProgramController_GetProcessorCurrentProgram_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programControllerClient) GetProcessorCurrentProgramName(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, ProgramController_GetProcessorCurrentProgramName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programControllerClient) GetProcessorProgramName(ctx context.Context, in *ProcessorProgramIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, ProgramController_GetProcessorProgramName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programControllerClient) GetProcessorPrograms(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ProgramInfoList, error) {
	out := new(ProgramInfoList)
	err := c.cc.Invoke(ctx, ProgramController_GetProcessorPrograms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *programControllerClient) SetProcessorProgram(ctx context.Context, in *ProcessorProgramSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, ProgramController_SetProcessorProgram_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProgramControllerServer is the server API for ProgramController service.
// All implementations must embed UnimplementedProgramControllerServer
// for forward compatibility
type ProgramControllerServer interface {
	GetProcessorCurrentProgram(context.Context, *ProcessorIdentifier) (*ProgramIdentifier, error)
	GetProcessorCurrentProgramName(context.Context, *ProcessorIdentifier) (*GenericStringValue, error)
	GetProcessorProgramName(context.Context, *ProcessorProgramIdentifier) (*GenericStringValue, error)
	GetProcessorPrograms(context.Context, *ProcessorIdentifier) (*ProgramInfoList, error)
	SetProcessorProgram(context.Context, *ProcessorProgramSetRequest) (*GenericVoidValue, error)
	mustEmbedUnimplementedProgramControllerServer()
}

// UnimplementedProgramControllerServer must be embedded to have forward compatible implementations.
type UnimplementedProgramControllerServer struct {
}

func (UnimplementedProgramControllerServer) GetProcessorCurrentProgram(context.Context, *ProcessorIdentifier) (*ProgramIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorCurrentProgram not implemented")
}
func (UnimplementedProgramControllerServer) GetProcessorCurrentProgramName(context.Context, *ProcessorIdentifier) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorCurrentProgramName not implemented")
}
func (UnimplementedProgramControllerServer) GetProcessorProgramName(context.Context, *ProcessorProgramIdentifier) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorProgramName not implemented")
}
func (UnimplementedProgramControllerServer) GetProcessorPrograms(context.Context, *ProcessorIdentifier) (*ProgramInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorPrograms not implemented")
}
func (UnimplementedProgramControllerServer) SetProcessorProgram(context.Context, *ProcessorProgramSetRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProcessorProgram not implemented")
}
func (UnimplementedProgramControllerServer) mustEmbedUnimplementedProgramControllerServer() {}

// UnsafeProgramControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProgramControllerServer will
// result in compilation errors.
type UnsafeProgramControllerServer interface {
	mustEmbedUnimplementedProgramControllerServer()
}

func RegisterProgramControllerServer(s grpc.ServiceRegistrar, srv ProgramControllerServer) {
	s.RegisterService(&ProgramController_ServiceDesc, srv)
}

func _ProgramController_GetProcessorCurrentProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramControllerServer).GetProcessorCurrentProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProgramController_GetProcessorCurrentProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramControllerServer).GetProcessorCurrentProgram(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgramController_GetProcessorCurrentProgramName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramControllerServer).GetProcessorCurrentProgramName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProgramController_GetProcessorCurrentProgramName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramControllerServer).GetProcessorCurrentProgramName(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgramController_GetProcessorProgramName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorProgramIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramControllerServer).GetProcessorProgramName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProgramController_GetProcessorProgramName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramControllerServer).GetProcessorProgramName(ctx, req.(*ProcessorProgramIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgramController_GetProcessorPrograms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramControllerServer).GetProcessorPrograms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProgramController_GetProcessorPrograms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramControllerServer).GetProcessorPrograms(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProgramController_SetProcessorProgram_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorProgramSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProgramControllerServer).SetProcessorProgram(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProgramController_SetProcessorProgram_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProgramControllerServer).SetProcessorProgram(ctx, req.(*ProcessorProgramSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProgramController_ServiceDesc is the grpc.ServiceDesc for ProgramController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProgramController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.ProgramController",
	HandlerType: (*ProgramControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProcessorCurrentProgram",
			Handler:    _ProgramController_GetProcessorCurrentProgram_Handler,
		},
		{
			MethodName: "GetProcessorCurrentProgramName",
			Handler:    _ProgramController_GetProcessorCurrentProgramName_Handler,
		},
		{
			MethodName: "GetProcessorProgramName",
			Handler:    _ProgramController_GetProcessorProgramName_Handler,
		},
		{
			MethodName: "GetProcessorPrograms",
			Handler:    _ProgramController_GetProcessorPrograms_Handler,
		},
		{
			MethodName: "SetProcessorProgram",
			Handler:    _ProgramController_SetProcessorProgram_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	ParameterController_GetTrackParameters_FullMethodName        = "/sushi_rpc.ParameterController/GetTrackParameters"
	ParameterController_GetProcessorParameters_FullMethodName    = "/sushi_rpc.ParameterController/GetProcessorParameters"
	ParameterController_GetParameterId_FullMethodName            = "/sushi_rpc.ParameterController/GetParameterId"
	ParameterController_GetParameterInfo_FullMethodName          = "/sushi_rpc.ParameterController/GetParameterInfo"
	ParameterController_GetParameterValue_FullMethodName         = "/sushi_rpc.ParameterController/GetParameterValue"
	ParameterController_GetParameterValueInDomain_FullMethodName = "/sushi_rpc.ParameterController/GetParameterValueInDomain"
	ParameterController_GetParameterValueAsString_FullMethodName = "/sushi_rpc.ParameterController/GetParameterValueAsString"
	ParameterController_SetParameterValue_FullMethodName         = "/sushi_rpc.ParameterController/SetParameterValue"
	ParameterController_GetTrackProperties_FullMethodName        = "/sushi_rpc.ParameterController/GetTrackProperties"
	ParameterController_GetProcessorProperties_FullMethodName    = "/sushi_rpc.ParameterController/GetProcessorProperties"
	ParameterController_GetPropertyId_FullMethodName             = "/sushi_rpc.ParameterController/GetPropertyId"
	ParameterController_GetPropertyInfo_FullMethodName           = "/sushi_rpc.ParameterController/GetPropertyInfo"
	ParameterController_GetPropertyValue_FullMethodName          = "/sushi_rpc.ParameterController/GetPropertyValue"
	ParameterController_SetPropertyValue_FullMethodName          = "/sushi_rpc.ParameterController/SetPropertyValue"
)

// ParameterControllerClient is the client API for ParameterController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParameterControllerClient interface {
	GetTrackParameters(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*ParameterInfoList, error)
	GetProcessorParameters(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ParameterInfoList, error)
	GetParameterId(ctx context.Context, in *ParameterIdRequest, opts ...grpc.CallOption) (*ParameterIdentifier, error)
	GetParameterInfo(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*ParameterInfo, error)
	GetParameterValue(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericFloatValue, error)
	GetParameterValueInDomain(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericFloatValue, error)
	GetParameterValueAsString(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error)
	SetParameterValue(ctx context.Context, in *ParameterValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
	GetTrackProperties(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*PropertyInfoList, error)
	GetProcessorProperties(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*PropertyInfoList, error)
	GetPropertyId(ctx context.Context, in *PropertyIdRequest, opts ...grpc.CallOption) (*PropertyIdentifier, error)
	GetPropertyInfo(ctx context.Context, in *PropertyIdentifier, opts ...grpc.CallOption) (*PropertyInfo, error)
	GetPropertyValue(ctx context.Context, in *PropertyIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error)
	SetPropertyValue(ctx context.Context, in *PropertyValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type parameterControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewParameterControllerClient(cc grpc.ClientConnInterface) ParameterControllerClient {
	return &parameterControllerClient{cc}
}

func (c *parameterControllerClient) GetTrackParameters(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*ParameterInfoList, error) {
	out := new(ParameterInfoList)
	err := c.cc.Invoke(ctx, ParameterController_GetTrackParameters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetProcessorParameters(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*ParameterInfoList, error) {
	out := new(ParameterInfoList)
	err := c.cc.Invoke(ctx, ParameterController_GetProcessorParameters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetParameterId(ctx context.Context, in *ParameterIdRequest, opts ...grpc.CallOption) (*ParameterIdentifier, error) {
	out := new(ParameterIdentifier)
	err := c.cc.Invoke(ctx, ParameterController_GetParameterId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetParameterInfo(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*ParameterInfo, error) {
	out := new(ParameterInfo)
	err := c.cc.Invoke(ctx, ParameterController_GetParameterInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetParameterValue(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericFloatValue, error) {
	out := new(GenericFloatValue)
	err := c.cc.Invoke(ctx, ParameterController_GetParameterValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetParameterValueInDomain(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericFloatValue, error) {
	out := new(GenericFloatValue)
	err := c.cc.Invoke(ctx, ParameterController_GetParameterValueInDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetParameterValueAsString(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, ParameterController_GetParameterValueAsString_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) SetParameterValue(ctx context.Context, in *ParameterValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, ParameterController_SetParameterValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetTrackProperties(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*PropertyInfoList, error) {
	out := new(PropertyInfoList)
	err := c.cc.Invoke(ctx, ParameterController_GetTrackProperties_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetProcessorProperties(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*PropertyInfoList, error) {
	out := new(PropertyInfoList)
	err := c.cc.Invoke(ctx, ParameterController_GetProcessorProperties_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetPropertyId(ctx context.Context, in *PropertyIdRequest, opts ...grpc.CallOption) (*PropertyIdentifier, error) {
	out := new(PropertyIdentifier)
	err := c.cc.Invoke(ctx, ParameterController_GetPropertyId_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetPropertyInfo(ctx context.Context, in *PropertyIdentifier, opts ...grpc.CallOption) (*PropertyInfo, error) {
	out := new(PropertyInfo)
	err := c.cc.Invoke(ctx, ParameterController_GetPropertyInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) GetPropertyValue(ctx context.Context, in *PropertyIdentifier, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, ParameterController_GetPropertyValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *parameterControllerClient) SetPropertyValue(ctx context.Context, in *PropertyValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, ParameterController_SetPropertyValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParameterControllerServer is the server API for ParameterController service.
// All implementations must embed UnimplementedParameterControllerServer
// for forward compatibility
type ParameterControllerServer interface {
	GetTrackParameters(context.Context, *TrackIdentifier) (*ParameterInfoList, error)
	GetProcessorParameters(context.Context, *ProcessorIdentifier) (*ParameterInfoList, error)
	GetParameterId(context.Context, *ParameterIdRequest) (*ParameterIdentifier, error)
	GetParameterInfo(context.Context, *ParameterIdentifier) (*ParameterInfo, error)
	GetParameterValue(context.Context, *ParameterIdentifier) (*GenericFloatValue, error)
	GetParameterValueInDomain(context.Context, *ParameterIdentifier) (*GenericFloatValue, error)
	GetParameterValueAsString(context.Context, *ParameterIdentifier) (*GenericStringValue, error)
	SetParameterValue(context.Context, *ParameterValue) (*GenericVoidValue, error)
	GetTrackProperties(context.Context, *TrackIdentifier) (*PropertyInfoList, error)
	GetProcessorProperties(context.Context, *ProcessorIdentifier) (*PropertyInfoList, error)
	GetPropertyId(context.Context, *PropertyIdRequest) (*PropertyIdentifier, error)
	GetPropertyInfo(context.Context, *PropertyIdentifier) (*PropertyInfo, error)
	GetPropertyValue(context.Context, *PropertyIdentifier) (*GenericStringValue, error)
	SetPropertyValue(context.Context, *PropertyValue) (*GenericVoidValue, error)
	mustEmbedUnimplementedParameterControllerServer()
}

// UnimplementedParameterControllerServer must be embedded to have forward compatible implementations.
type UnimplementedParameterControllerServer struct {
}

func (UnimplementedParameterControllerServer) GetTrackParameters(context.Context, *TrackIdentifier) (*ParameterInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackParameters not implemented")
}
func (UnimplementedParameterControllerServer) GetProcessorParameters(context.Context, *ProcessorIdentifier) (*ParameterInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorParameters not implemented")
}
func (UnimplementedParameterControllerServer) GetParameterId(context.Context, *ParameterIdRequest) (*ParameterIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameterId not implemented")
}
func (UnimplementedParameterControllerServer) GetParameterInfo(context.Context, *ParameterIdentifier) (*ParameterInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameterInfo not implemented")
}
func (UnimplementedParameterControllerServer) GetParameterValue(context.Context, *ParameterIdentifier) (*GenericFloatValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameterValue not implemented")
}
func (UnimplementedParameterControllerServer) GetParameterValueInDomain(context.Context, *ParameterIdentifier) (*GenericFloatValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameterValueInDomain not implemented")
}
func (UnimplementedParameterControllerServer) GetParameterValueAsString(context.Context, *ParameterIdentifier) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParameterValueAsString not implemented")
}
func (UnimplementedParameterControllerServer) SetParameterValue(context.Context, *ParameterValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetParameterValue not implemented")
}
func (UnimplementedParameterControllerServer) GetTrackProperties(context.Context, *TrackIdentifier) (*PropertyInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrackProperties not implemented")
}
func (UnimplementedParameterControllerServer) GetProcessorProperties(context.Context, *ProcessorIdentifier) (*PropertyInfoList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessorProperties not implemented")
}
func (UnimplementedParameterControllerServer) GetPropertyId(context.Context, *PropertyIdRequest) (*PropertyIdentifier, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPropertyId not implemented")
}
func (UnimplementedParameterControllerServer) GetPropertyInfo(context.Context, *PropertyIdentifier) (*PropertyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPropertyInfo not implemented")
}
func (UnimplementedParameterControllerServer) GetPropertyValue(context.Context, *PropertyIdentifier) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPropertyValue not implemented")
}
func (UnimplementedParameterControllerServer) SetPropertyValue(context.Context, *PropertyValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPropertyValue not implemented")
}
func (UnimplementedParameterControllerServer) mustEmbedUnimplementedParameterControllerServer() {}

// UnsafeParameterControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParameterControllerServer will
// result in compilation errors.
type UnsafeParameterControllerServer interface {
	mustEmbedUnimplementedParameterControllerServer()
}

func RegisterParameterControllerServer(s grpc.ServiceRegistrar, srv ParameterControllerServer) {
	s.RegisterService(&ParameterController_ServiceDesc, srv)
}

func _ParameterController_GetTrackParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetTrackParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetTrackParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetTrackParameters(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetProcessorParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetProcessorParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetProcessorParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetProcessorParameters(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetParameterId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetParameterId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetParameterId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetParameterId(ctx, req.(*ParameterIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetParameterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetParameterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetParameterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetParameterInfo(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetParameterValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetParameterValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetParameterValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetParameterValue(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetParameterValueInDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetParameterValueInDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetParameterValueInDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetParameterValueInDomain(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetParameterValueAsString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetParameterValueAsString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetParameterValueAsString_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetParameterValueAsString(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_SetParameterValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).SetParameterValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_SetParameterValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).SetParameterValue(ctx, req.(*ParameterValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetTrackProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetTrackProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetTrackProperties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetTrackProperties(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetProcessorProperties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetProcessorProperties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetProcessorProperties_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetProcessorProperties(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetPropertyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropertyIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetPropertyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetPropertyId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetPropertyId(ctx, req.(*PropertyIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetPropertyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropertyIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetPropertyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetPropertyInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetPropertyInfo(ctx, req.(*PropertyIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_GetPropertyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropertyIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).GetPropertyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_GetPropertyValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).GetPropertyValue(ctx, req.(*PropertyIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParameterController_SetPropertyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PropertyValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParameterControllerServer).SetPropertyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ParameterController_SetPropertyValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParameterControllerServer).SetPropertyValue(ctx, req.(*PropertyValue))
	}
	return interceptor(ctx, in, info, handler)
}

// ParameterController_ServiceDesc is the grpc.ServiceDesc for ParameterController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ParameterController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.ParameterController",
	HandlerType: (*ParameterControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTrackParameters",
			Handler:    _ParameterController_GetTrackParameters_Handler,
		},
		{
			MethodName: "GetProcessorParameters",
			Handler:    _ParameterController_GetProcessorParameters_Handler,
		},
		{
			MethodName: "GetParameterId",
			Handler:    _ParameterController_GetParameterId_Handler,
		},
		{
			MethodName: "GetParameterInfo",
			Handler:    _ParameterController_GetParameterInfo_Handler,
		},
		{
			MethodName: "GetParameterValue",
			Handler:    _ParameterController_GetParameterValue_Handler,
		},
		{
			MethodName: "GetParameterValueInDomain",
			Handler:    _ParameterController_GetParameterValueInDomain_Handler,
		},
		{
			MethodName: "GetParameterValueAsString",
			Handler:    _ParameterController_GetParameterValueAsString_Handler,
		},
		{
			MethodName: "SetParameterValue",
			Handler:    _ParameterController_SetParameterValue_Handler,
		},
		{
			MethodName: "GetTrackProperties",
			Handler:    _ParameterController_GetTrackProperties_Handler,
		},
		{
			MethodName: "GetProcessorProperties",
			Handler:    _ParameterController_GetProcessorProperties_Handler,
		},
		{
			MethodName: "GetPropertyId",
			Handler:    _ParameterController_GetPropertyId_Handler,
		},
		{
			MethodName: "GetPropertyInfo",
			Handler:    _ParameterController_GetPropertyInfo_Handler,
		},
		{
			MethodName: "GetPropertyValue",
			Handler:    _ParameterController_GetPropertyValue_Handler,
		},
		{
			MethodName: "SetPropertyValue",
			Handler:    _ParameterController_SetPropertyValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	MidiController_GetInputPorts_FullMethodName                     = "/sushi_rpc.MidiController/GetInputPorts"
	MidiController_GetOutputPorts_FullMethodName                    = "/sushi_rpc.MidiController/GetOutputPorts"
	MidiController_GetAllKbdInputConnections_FullMethodName         = "/sushi_rpc.MidiController/GetAllKbdInputConnections"
	MidiController_GetAllKbdOutputConnections_FullMethodName        = "/sushi_rpc.MidiController/GetAllKbdOutputConnections"
	MidiController_GetAllCCInputConnections_FullMethodName          = "/sushi_rpc.MidiController/GetAllCCInputConnections"
	MidiController_GetAllPCInputConnections_FullMethodName          = "/sushi_rpc.MidiController/GetAllPCInputConnections"
	MidiController_GetCCInputConnectionsForProcessor_FullMethodName = "/sushi_rpc.MidiController/GetCCInputConnectionsForProcessor"
	MidiController_GetPCInputConnectionsForProcessor_FullMethodName = "/sushi_rpc.MidiController/GetPCInputConnectionsForProcessor"
	MidiController_GetMidiClockOutputEnabled_FullMethodName         = "/sushi_rpc.MidiController/GetMidiClockOutputEnabled"
	MidiController_SetMidiClockOutputEnabled_FullMethodName         = "/sushi_rpc.MidiController/SetMidiClockOutputEnabled"
	MidiController_ConnectKbdInputToTrack_FullMethodName            = "/sushi_rpc.MidiController/ConnectKbdInputToTrack"
	MidiController_ConnectKbdOutputFromTrack_FullMethodName         = "/sushi_rpc.MidiController/ConnectKbdOutputFromTrack"
	MidiController_ConnectCCToParameter_FullMethodName              = "/sushi_rpc.MidiController/ConnectCCToParameter"
	MidiController_ConnectPCToProcessor_FullMethodName              = "/sushi_rpc.MidiController/ConnectPCToProcessor"
	MidiController_DisconnectKbdInput_FullMethodName                = "/sushi_rpc.MidiController/DisconnectKbdInput"
	MidiController_DisconnectKbdOutput_FullMethodName               = "/sushi_rpc.MidiController/DisconnectKbdOutput"
	MidiController_DisconnectCC_FullMethodName                      = "/sushi_rpc.MidiController/DisconnectCC"
	MidiController_DisconnectPC_FullMethodName                      = "/sushi_rpc.MidiController/DisconnectPC"
	MidiController_DisconnectAllCCFromProcessor_FullMethodName      = "/sushi_rpc.MidiController/DisconnectAllCCFromProcessor"
	MidiController_DisconnectAllPCFromProcessor_FullMethodName      = "/sushi_rpc.MidiController/DisconnectAllPCFromProcessor"
)

// MidiControllerClient is the client API for MidiController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MidiControllerClient interface {
	GetInputPorts(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetOutputPorts(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetAllKbdInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiKbdConnectionList, error)
	GetAllKbdOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiKbdConnectionList, error)
	GetAllCCInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiCCConnectionList, error)
	GetAllPCInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiPCConnectionList, error)
	GetCCInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*MidiCCConnectionList, error)
	GetPCInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*MidiPCConnectionList, error)
	GetMidiClockOutputEnabled(ctx context.Context, in *GenericIntValue, opts ...grpc.CallOption) (*GenericBoolValue, error)
	SetMidiClockOutputEnabled(ctx context.Context, in *MidiClockSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectKbdInputToTrack(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectKbdOutputFromTrack(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectCCToParameter(ctx context.Context, in *MidiCCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectPCToProcessor(ctx context.Context, in *MidiPCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectKbdInput(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectKbdOutput(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectCC(ctx context.Context, in *MidiCCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectPC(ctx context.Context, in *MidiPCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllCCFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllPCFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type midiControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewMidiControllerClient(cc grpc.ClientConnInterface) MidiControllerClient {
	return &midiControllerClient{cc}
}

func (c *midiControllerClient) GetInputPorts(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, MidiController_GetInputPorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetOutputPorts(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, MidiController_GetOutputPorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetAllKbdInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiKbdConnectionList, error) {
	out := new(MidiKbdConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetAllKbdInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetAllKbdOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiKbdConnectionList, error) {
	out := new(MidiKbdConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetAllKbdOutputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetAllCCInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiCCConnectionList, error) {
	out := new(MidiCCConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetAllCCInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetAllPCInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*MidiPCConnectionList, error) {
	out := new(MidiPCConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetAllPCInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetCCInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*MidiCCConnectionList, error) {
	out := new(MidiCCConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetCCInputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetPCInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*MidiPCConnectionList, error) {
	out := new(MidiPCConnectionList)
	err := c.cc.Invoke(ctx, MidiController_GetPCInputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) GetMidiClockOutputEnabled(ctx context.Context, in *GenericIntValue, opts ...grpc.CallOption) (*GenericBoolValue, error) {
	out := new(GenericBoolValue)
	err := c.cc.Invoke(ctx, MidiController_GetMidiClockOutputEnabled_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) SetMidiClockOutputEnabled(ctx context.Context, in *MidiClockSetRequest, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_SetMidiClockOutputEnabled_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) ConnectKbdInputToTrack(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_ConnectKbdInputToTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) ConnectKbdOutputFromTrack(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_ConnectKbdOutputFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) ConnectCCToParameter(ctx context.Context, in *MidiCCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_ConnectCCToParameter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) ConnectPCToProcessor(ctx context.Context, in *MidiPCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_ConnectPCToProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectKbdInput(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectKbdInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectKbdOutput(ctx context.Context, in *MidiKbdConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectKbdOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectCC(ctx context.Context, in *MidiCCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectCC_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectPC(ctx context.Context, in *MidiPCConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectPC_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectAllCCFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectAllCCFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *midiControllerClient) DisconnectAllPCFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, MidiController_DisconnectAllPCFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MidiControllerServer is the server API for MidiController service.
// All implementations must embed UnimplementedMidiControllerServer
// for forward compatibility
type MidiControllerServer interface {
	GetInputPorts(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetOutputPorts(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetAllKbdInputConnections(context.Context, *GenericVoidValue) (*MidiKbdConnectionList, error)
	GetAllKbdOutputConnections(context.Context, *GenericVoidValue) (*MidiKbdConnectionList, error)
	GetAllCCInputConnections(context.Context, *GenericVoidValue) (*MidiCCConnectionList, error)
	GetAllPCInputConnections(context.Context, *GenericVoidValue) (*MidiPCConnectionList, error)
	GetCCInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*MidiCCConnectionList, error)
	GetPCInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*MidiPCConnectionList, error)
	GetMidiClockOutputEnabled(context.Context, *GenericIntValue) (*GenericBoolValue, error)
	SetMidiClockOutputEnabled(context.Context, *MidiClockSetRequest) (*GenericVoidValue, error)
	ConnectKbdInputToTrack(context.Context, *MidiKbdConnection) (*GenericVoidValue, error)
	ConnectKbdOutputFromTrack(context.Context, *MidiKbdConnection) (*GenericVoidValue, error)
	ConnectCCToParameter(context.Context, *MidiCCConnection) (*GenericVoidValue, error)
	ConnectPCToProcessor(context.Context, *MidiPCConnection) (*GenericVoidValue, error)
	DisconnectKbdInput(context.Context, *MidiKbdConnection) (*GenericVoidValue, error)
	DisconnectKbdOutput(context.Context, *MidiKbdConnection) (*GenericVoidValue, error)
	DisconnectCC(context.Context, *MidiCCConnection) (*GenericVoidValue, error)
	DisconnectPC(context.Context, *MidiPCConnection) (*GenericVoidValue, error)
	DisconnectAllCCFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	DisconnectAllPCFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	mustEmbedUnimplementedMidiControllerServer()
}

// UnimplementedMidiControllerServer must be embedded to have forward compatible implementations.
type UnimplementedMidiControllerServer struct {
}

func (UnimplementedMidiControllerServer) GetInputPorts(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputPorts not implemented")
}
func (UnimplementedMidiControllerServer) GetOutputPorts(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputPorts not implemented")
}
func (UnimplementedMidiControllerServer) GetAllKbdInputConnections(context.Context, *GenericVoidValue) (*MidiKbdConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllKbdInputConnections not implemented")
}
func (UnimplementedMidiControllerServer) GetAllKbdOutputConnections(context.Context, *GenericVoidValue) (*MidiKbdConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllKbdOutputConnections not implemented")
}
func (UnimplementedMidiControllerServer) GetAllCCInputConnections(context.Context, *GenericVoidValue) (*MidiCCConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCCInputConnections not implemented")
}
func (UnimplementedMidiControllerServer) GetAllPCInputConnections(context.Context, *GenericVoidValue) (*MidiPCConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllPCInputConnections not implemented")
}
func (UnimplementedMidiControllerServer) GetCCInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*MidiCCConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCCInputConnectionsForProcessor not implemented")
}
func (UnimplementedMidiControllerServer) GetPCInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*MidiPCConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPCInputConnectionsForProcessor not implemented")
}
func (UnimplementedMidiControllerServer) GetMidiClockOutputEnabled(context.Context, *GenericIntValue) (*GenericBoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMidiClockOutputEnabled not implemented")
}
func (UnimplementedMidiControllerServer) SetMidiClockOutputEnabled(context.Context, *MidiClockSetRequest) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMidiClockOutputEnabled not implemented")
}
func (UnimplementedMidiControllerServer) ConnectKbdInputToTrack(context.Context, *MidiKbdConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectKbdInputToTrack not implemented")
}
func (UnimplementedMidiControllerServer) ConnectKbdOutputFromTrack(context.Context, *MidiKbdConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectKbdOutputFromTrack not implemented")
}
func (UnimplementedMidiControllerServer) ConnectCCToParameter(context.Context, *MidiCCConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectCCToParameter not implemented")
}
func (UnimplementedMidiControllerServer) ConnectPCToProcessor(context.Context, *MidiPCConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectPCToProcessor not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectKbdInput(context.Context, *MidiKbdConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectKbdInput not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectKbdOutput(context.Context, *MidiKbdConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectKbdOutput not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectCC(context.Context, *MidiCCConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectCC not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectPC(context.Context, *MidiPCConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectPC not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectAllCCFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllCCFromProcessor not implemented")
}
func (UnimplementedMidiControllerServer) DisconnectAllPCFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllPCFromProcessor not implemented")
}
func (UnimplementedMidiControllerServer) mustEmbedUnimplementedMidiControllerServer() {}

// UnsafeMidiControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MidiControllerServer will
// result in compilation errors.
type UnsafeMidiControllerServer interface {
	mustEmbedUnimplementedMidiControllerServer()
}

func RegisterMidiControllerServer(s grpc.ServiceRegistrar, srv MidiControllerServer) {
	s.RegisterService(&MidiController_ServiceDesc, srv)
}

func _MidiController_GetInputPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetInputPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetInputPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetInputPorts(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetOutputPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetOutputPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetOutputPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetOutputPorts(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetAllKbdInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetAllKbdInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetAllKbdInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetAllKbdInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetAllKbdOutputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetAllKbdOutputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetAllKbdOutputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetAllKbdOutputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetAllCCInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetAllCCInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetAllCCInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetAllCCInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetAllPCInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetAllPCInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetAllPCInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetAllPCInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetCCInputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetCCInputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetCCInputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetCCInputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetPCInputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetPCInputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetPCInputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetPCInputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_GetMidiClockOutputEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericIntValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).GetMidiClockOutputEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_GetMidiClockOutputEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).GetMidiClockOutputEnabled(ctx, req.(*GenericIntValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_SetMidiClockOutputEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiClockSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).SetMidiClockOutputEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_SetMidiClockOutputEnabled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).SetMidiClockOutputEnabled(ctx, req.(*MidiClockSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_ConnectKbdInputToTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiKbdConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).ConnectKbdInputToTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_ConnectKbdInputToTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).ConnectKbdInputToTrack(ctx, req.(*MidiKbdConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_ConnectKbdOutputFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiKbdConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).ConnectKbdOutputFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_ConnectKbdOutputFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).ConnectKbdOutputFromTrack(ctx, req.(*MidiKbdConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_ConnectCCToParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiCCConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).ConnectCCToParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_ConnectCCToParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).ConnectCCToParameter(ctx, req.(*MidiCCConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_ConnectPCToProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiPCConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).ConnectPCToProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_ConnectPCToProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).ConnectPCToProcessor(ctx, req.(*MidiPCConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectKbdInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiKbdConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectKbdInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectKbdInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectKbdInput(ctx, req.(*MidiKbdConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectKbdOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiKbdConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectKbdOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectKbdOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectKbdOutput(ctx, req.(*MidiKbdConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectCC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiCCConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectCC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectCC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectCC(ctx, req.(*MidiCCConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MidiPCConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectPC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectPC(ctx, req.(*MidiPCConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectAllCCFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectAllCCFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectAllCCFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectAllCCFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _MidiController_DisconnectAllPCFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MidiControllerServer).DisconnectAllPCFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MidiController_DisconnectAllPCFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MidiControllerServer).DisconnectAllPCFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// MidiController_ServiceDesc is the grpc.ServiceDesc for MidiController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MidiController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.MidiController",
	HandlerType: (*MidiControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInputPorts",
			Handler:    _MidiController_GetInputPorts_Handler,
		},
		{
			MethodName: "GetOutputPorts",
			Handler:    _MidiController_GetOutputPorts_Handler,
		},
		{
			MethodName: "GetAllKbdInputConnections",
			Handler:    _MidiController_GetAllKbdInputConnections_Handler,
		},
		{
			MethodName: "GetAllKbdOutputConnections",
			Handler:    _MidiController_GetAllKbdOutputConnections_Handler,
		},
		{
			MethodName: "GetAllCCInputConnections",
			Handler:    _MidiController_GetAllCCInputConnections_Handler,
		},
		{
			MethodName: "GetAllPCInputConnections",
			Handler:    _MidiController_GetAllPCInputConnections_Handler,
		},
		{
			MethodName: "GetCCInputConnectionsForProcessor",
			Handler:    _MidiController_GetCCInputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "GetPCInputConnectionsForProcessor",
			Handler:    _MidiController_GetPCInputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "GetMidiClockOutputEnabled",
			Handler:    _MidiController_GetMidiClockOutputEnabled_Handler,
		},
		{
			MethodName: "SetMidiClockOutputEnabled",
			Handler:    _MidiController_SetMidiClockOutputEnabled_Handler,
		},
		{
			MethodName: "ConnectKbdInputToTrack",
			Handler:    _MidiController_ConnectKbdInputToTrack_Handler,
		},
		{
			MethodName: "ConnectKbdOutputFromTrack",
			Handler:    _MidiController_ConnectKbdOutputFromTrack_Handler,
		},
		{
			MethodName: "ConnectCCToParameter",
			Handler:    _MidiController_ConnectCCToParameter_Handler,
		},
		{
			MethodName: "ConnectPCToProcessor",
			Handler:    _MidiController_ConnectPCToProcessor_Handler,
		},
		{
			MethodName: "DisconnectKbdInput",
			Handler:    _MidiController_DisconnectKbdInput_Handler,
		},
		{
			MethodName: "DisconnectKbdOutput",
			Handler:    _MidiController_DisconnectKbdOutput_Handler,
		},
		{
			MethodName: "DisconnectCC",
			Handler:    _MidiController_DisconnectCC_Handler,
		},
		{
			MethodName: "DisconnectPC",
			Handler:    _MidiController_DisconnectPC_Handler,
		},
		{
			MethodName: "DisconnectAllCCFromProcessor",
			Handler:    _MidiController_DisconnectAllCCFromProcessor_Handler,
		},
		{
			MethodName: "DisconnectAllPCFromProcessor",
			Handler:    _MidiController_DisconnectAllPCFromProcessor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	AudioRoutingController_GetAllInputConnections_FullMethodName        = "/sushi_rpc.AudioRoutingController/GetAllInputConnections"
	AudioRoutingController_GetAllOutputConnections_FullMethodName       = "/sushi_rpc.AudioRoutingController/GetAllOutputConnections"
	AudioRoutingController_GetInputConnectionsForTrack_FullMethodName   = "/sushi_rpc.AudioRoutingController/GetInputConnectionsForTrack"
	AudioRoutingController_GetOutputConnectionsForTrack_FullMethodName  = "/sushi_rpc.AudioRoutingController/GetOutputConnectionsForTrack"
	AudioRoutingController_ConnectInputChannelToTrack_FullMethodName    = "/sushi_rpc.AudioRoutingController/ConnectInputChannelToTrack"
	AudioRoutingController_ConnectOutputChannelFromTrack_FullMethodName = "/sushi_rpc.AudioRoutingController/ConnectOutputChannelFromTrack"
	AudioRoutingController_DisconnectInput_FullMethodName               = "/sushi_rpc.AudioRoutingController/DisconnectInput"
	AudioRoutingController_DisconnectOutput_FullMethodName              = "/sushi_rpc.AudioRoutingController/DisconnectOutput"
	AudioRoutingController_DisconnectAllInputsFromTrack_FullMethodName  = "/sushi_rpc.AudioRoutingController/DisconnectAllInputsFromTrack"
	AudioRoutingController_DisconnectAllOutputFromTrack_FullMethodName  = "/sushi_rpc.AudioRoutingController/DisconnectAllOutputFromTrack"
	AudioRoutingController_DisconnectAllOutputsFromTrack_FullMethodName = "/sushi_rpc.AudioRoutingController/DisconnectAllOutputsFromTrack"
)

// AudioRoutingControllerClient is the client API for AudioRoutingController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AudioRoutingControllerClient interface {
	GetAllInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*AudioConnectionList, error)
	GetAllOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*AudioConnectionList, error)
	GetInputConnectionsForTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*AudioConnectionList, error)
	GetOutputConnectionsForTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*AudioConnectionList, error)
	ConnectInputChannelToTrack(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectOutputChannelFromTrack(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectInput(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectOutput(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllInputsFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	// Deprecated: Do not use.
	DisconnectAllOutputFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllOutputsFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type audioRoutingControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewAudioRoutingControllerClient(cc grpc.ClientConnInterface) AudioRoutingControllerClient {
	return &audioRoutingControllerClient{cc}
}

func (c *audioRoutingControllerClient) GetAllInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*AudioConnectionList, error) {
	out := new(AudioConnectionList)
	err := c.cc.Invoke(ctx, AudioRoutingController_GetAllInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) GetAllOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*AudioConnectionList, error) {
	out := new(AudioConnectionList)
	err := c.cc.Invoke(ctx, AudioRoutingController_GetAllOutputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) GetInputConnectionsForTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*AudioConnectionList, error) {
	out := new(AudioConnectionList)
	err := c.cc.Invoke(ctx, AudioRoutingController_GetInputConnectionsForTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) GetOutputConnectionsForTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*AudioConnectionList, error) {
	out := new(AudioConnectionList)
	err := c.cc.Invoke(ctx, AudioRoutingController_GetOutputConnectionsForTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) ConnectInputChannelToTrack(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_ConnectInputChannelToTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) ConnectOutputChannelFromTrack(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_ConnectOutputChannelFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) DisconnectInput(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_DisconnectInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) DisconnectOutput(ctx context.Context, in *AudioConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_DisconnectOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) DisconnectAllInputsFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_DisconnectAllInputsFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *audioRoutingControllerClient) DisconnectAllOutputFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_DisconnectAllOutputFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioRoutingControllerClient) DisconnectAllOutputsFromTrack(ctx context.Context, in *TrackIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, AudioRoutingController_DisconnectAllOutputsFromTrack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AudioRoutingControllerServer is the server API for AudioRoutingController service.
// All implementations must embed UnimplementedAudioRoutingControllerServer
// for forward compatibility
type AudioRoutingControllerServer interface {
	GetAllInputConnections(context.Context, *GenericVoidValue) (*AudioConnectionList, error)
	GetAllOutputConnections(context.Context, *GenericVoidValue) (*AudioConnectionList, error)
	GetInputConnectionsForTrack(context.Context, *TrackIdentifier) (*AudioConnectionList, error)
	GetOutputConnectionsForTrack(context.Context, *TrackIdentifier) (*AudioConnectionList, error)
	ConnectInputChannelToTrack(context.Context, *AudioConnection) (*GenericVoidValue, error)
	ConnectOutputChannelFromTrack(context.Context, *AudioConnection) (*GenericVoidValue, error)
	DisconnectInput(context.Context, *AudioConnection) (*GenericVoidValue, error)
	DisconnectOutput(context.Context, *AudioConnection) (*GenericVoidValue, error)
	DisconnectAllInputsFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error)
	// Deprecated: Do not use.
	DisconnectAllOutputFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error)
	DisconnectAllOutputsFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error)
	mustEmbedUnimplementedAudioRoutingControllerServer()
}

// UnimplementedAudioRoutingControllerServer must be embedded to have forward compatible implementations.
type UnimplementedAudioRoutingControllerServer struct {
}

func (UnimplementedAudioRoutingControllerServer) GetAllInputConnections(context.Context, *GenericVoidValue) (*AudioConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllInputConnections not implemented")
}
func (UnimplementedAudioRoutingControllerServer) GetAllOutputConnections(context.Context, *GenericVoidValue) (*AudioConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllOutputConnections not implemented")
}
func (UnimplementedAudioRoutingControllerServer) GetInputConnectionsForTrack(context.Context, *TrackIdentifier) (*AudioConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInputConnectionsForTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) GetOutputConnectionsForTrack(context.Context, *TrackIdentifier) (*AudioConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputConnectionsForTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) ConnectInputChannelToTrack(context.Context, *AudioConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectInputChannelToTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) ConnectOutputChannelFromTrack(context.Context, *AudioConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectOutputChannelFromTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) DisconnectInput(context.Context, *AudioConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectInput not implemented")
}
func (UnimplementedAudioRoutingControllerServer) DisconnectOutput(context.Context, *AudioConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectOutput not implemented")
}
func (UnimplementedAudioRoutingControllerServer) DisconnectAllInputsFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllInputsFromTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) DisconnectAllOutputFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllOutputFromTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) DisconnectAllOutputsFromTrack(context.Context, *TrackIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllOutputsFromTrack not implemented")
}
func (UnimplementedAudioRoutingControllerServer) mustEmbedUnimplementedAudioRoutingControllerServer() {
}

// UnsafeAudioRoutingControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AudioRoutingControllerServer will
// result in compilation errors.
type UnsafeAudioRoutingControllerServer interface {
	mustEmbedUnimplementedAudioRoutingControllerServer()
}

func RegisterAudioRoutingControllerServer(s grpc.ServiceRegistrar, srv AudioRoutingControllerServer) {
	s.RegisterService(&AudioRoutingController_ServiceDesc, srv)
}

func _AudioRoutingController_GetAllInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).GetAllInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_GetAllInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).GetAllInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_GetAllOutputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).GetAllOutputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_GetAllOutputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).GetAllOutputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_GetInputConnectionsForTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).GetInputConnectionsForTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_GetInputConnectionsForTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).GetInputConnectionsForTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_GetOutputConnectionsForTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).GetOutputConnectionsForTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_GetOutputConnectionsForTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).GetOutputConnectionsForTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_ConnectInputChannelToTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).ConnectInputChannelToTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_ConnectInputChannelToTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).ConnectInputChannelToTrack(ctx, req.(*AudioConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_ConnectOutputChannelFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).ConnectOutputChannelFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_ConnectOutputChannelFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).ConnectOutputChannelFromTrack(ctx, req.(*AudioConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_DisconnectInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).DisconnectInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_DisconnectInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).DisconnectInput(ctx, req.(*AudioConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_DisconnectOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).DisconnectOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_DisconnectOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).DisconnectOutput(ctx, req.(*AudioConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_DisconnectAllInputsFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).DisconnectAllInputsFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_DisconnectAllInputsFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).DisconnectAllInputsFromTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_DisconnectAllOutputFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).DisconnectAllOutputFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_DisconnectAllOutputFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).DisconnectAllOutputFromTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioRoutingController_DisconnectAllOutputsFromTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioRoutingControllerServer).DisconnectAllOutputsFromTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AudioRoutingController_DisconnectAllOutputsFromTrack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioRoutingControllerServer).DisconnectAllOutputsFromTrack(ctx, req.(*TrackIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// AudioRoutingController_ServiceDesc is the grpc.ServiceDesc for AudioRoutingController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AudioRoutingController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.AudioRoutingController",
	HandlerType: (*AudioRoutingControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllInputConnections",
			Handler:    _AudioRoutingController_GetAllInputConnections_Handler,
		},
		{
			MethodName: "GetAllOutputConnections",
			Handler:    _AudioRoutingController_GetAllOutputConnections_Handler,
		},
		{
			MethodName: "GetInputConnectionsForTrack",
			Handler:    _AudioRoutingController_GetInputConnectionsForTrack_Handler,
		},
		{
			MethodName: "GetOutputConnectionsForTrack",
			Handler:    _AudioRoutingController_GetOutputConnectionsForTrack_Handler,
		},
		{
			MethodName: "ConnectInputChannelToTrack",
			Handler:    _AudioRoutingController_ConnectInputChannelToTrack_Handler,
		},
		{
			MethodName: "ConnectOutputChannelFromTrack",
			Handler:    _AudioRoutingController_ConnectOutputChannelFromTrack_Handler,
		},
		{
			MethodName: "DisconnectInput",
			Handler:    _AudioRoutingController_DisconnectInput_Handler,
		},
		{
			MethodName: "DisconnectOutput",
			Handler:    _AudioRoutingController_DisconnectOutput_Handler,
		},
		{
			MethodName: "DisconnectAllInputsFromTrack",
			Handler:    _AudioRoutingController_DisconnectAllInputsFromTrack_Handler,
		},
		{
			MethodName: "DisconnectAllOutputFromTrack",
			Handler:    _AudioRoutingController_DisconnectAllOutputFromTrack_Handler,
		},
		{
			MethodName: "DisconnectAllOutputsFromTrack",
			Handler:    _AudioRoutingController_DisconnectAllOutputsFromTrack_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	CvGateController_GetCvInputChannelCount_FullMethodName                = "/sushi_rpc.CvGateController/GetCvInputChannelCount"
	CvGateController_GetCvOutputChannelCount_FullMethodName               = "/sushi_rpc.CvGateController/GetCvOutputChannelCount"
	CvGateController_GetAllCvInputConnections_FullMethodName              = "/sushi_rpc.CvGateController/GetAllCvInputConnections"
	CvGateController_GetAllCvOutputConnections_FullMethodName             = "/sushi_rpc.CvGateController/GetAllCvOutputConnections"
	CvGateController_GetAllGateInputConnections_FullMethodName            = "/sushi_rpc.CvGateController/GetAllGateInputConnections"
	CvGateController_GetAllGateOutputConnections_FullMethodName           = "/sushi_rpc.CvGateController/GetAllGateOutputConnections"
	CvGateController_GetCvInputConnectionsForProcessor_FullMethodName     = "/sushi_rpc.CvGateController/GetCvInputConnectionsForProcessor"
	CvGateController_GetCvOutputConnectionsForProcessor_FullMethodName    = "/sushi_rpc.CvGateController/GetCvOutputConnectionsForProcessor"
	CvGateController_GetGateInputConnectionsForProcessor_FullMethodName   = "/sushi_rpc.CvGateController/GetGateInputConnectionsForProcessor"
	CvGateController_GetGateOutputConnectionsForProcessor_FullMethodName  = "/sushi_rpc.CvGateController/GetGateOutputConnectionsForProcessor"
	CvGateController_ConnectCvInputToParameter_FullMethodName             = "/sushi_rpc.CvGateController/ConnectCvInputToParameter"
	CvGateController_ConnectCvOutputFromParameter_FullMethodName          = "/sushi_rpc.CvGateController/ConnectCvOutputFromParameter"
	CvGateController_ConnectGateInputToProcessor_FullMethodName           = "/sushi_rpc.CvGateController/ConnectGateInputToProcessor"
	CvGateController_ConnectGateOutputFromProcessor_FullMethodName        = "/sushi_rpc.CvGateController/ConnectGateOutputFromProcessor"
	CvGateController_DisconnectCvInput_FullMethodName                     = "/sushi_rpc.CvGateController/DisconnectCvInput"
	CvGateController_DisconnectCvOutput_FullMethodName                    = "/sushi_rpc.CvGateController/DisconnectCvOutput"
	CvGateController_DisconnectGateInput_FullMethodName                   = "/sushi_rpc.CvGateController/DisconnectGateInput"
	CvGateController_DisconnectGateOutput_FullMethodName                  = "/sushi_rpc.CvGateController/DisconnectGateOutput"
	CvGateController_DisconnectAllCvInputsFromProcessor_FullMethodName    = "/sushi_rpc.CvGateController/DisconnectAllCvInputsFromProcessor"
	CvGateController_DisconnectAllCvOutputsFromProcessor_FullMethodName   = "/sushi_rpc.CvGateController/DisconnectAllCvOutputsFromProcessor"
	CvGateController_DisconnectAllGateInputsFromProcessor_FullMethodName  = "/sushi_rpc.CvGateController/DisconnectAllGateInputsFromProcessor"
	CvGateController_DisconnectAllGateOutputsFromProcessor_FullMethodName = "/sushi_rpc.CvGateController/DisconnectAllGateOutputsFromProcessor"
)

// CvGateControllerClient is the client API for CvGateController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CvGateControllerClient interface {
	GetCvInputChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetCvOutputChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetAllCvInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CvConnectionList, error)
	GetAllCvOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CvConnectionList, error)
	GetAllGateInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GateConnectionList, error)
	GetAllGateOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GateConnectionList, error)
	GetCvInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CvConnectionList, error)
	GetCvOutputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CvConnectionList, error)
	GetGateInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GateConnectionList, error)
	GetGateOutputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GateConnectionList, error)
	ConnectCvInputToParameter(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectCvOutputFromParameter(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectGateInputToProcessor(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	ConnectGateOutputFromProcessor(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectCvInput(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectCvOutput(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectGateInput(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectGateOutput(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllCvInputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllCvOutputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllGateInputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisconnectAllGateOutputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type cvGateControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewCvGateControllerClient(cc grpc.ClientConnInterface) CvGateControllerClient {
	return &cvGateControllerClient{cc}
}

func (c *cvGateControllerClient) GetCvInputChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, CvGateController_GetCvInputChannelCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetCvOutputChannelCount(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, CvGateController_GetCvOutputChannelCount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetAllCvInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CvConnectionList, error) {
	out := new(CvConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetAllCvInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetAllCvOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*CvConnectionList, error) {
	out := new(CvConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetAllCvOutputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetAllGateInputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GateConnectionList, error) {
	out := new(GateConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetAllGateInputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetAllGateOutputConnections(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GateConnectionList, error) {
	out := new(GateConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetAllGateOutputConnections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetCvInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CvConnectionList, error) {
	out := new(CvConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetCvInputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetCvOutputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*CvConnectionList, error) {
	out := new(CvConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetCvOutputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetGateInputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GateConnectionList, error) {
	out := new(GateConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetGateInputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) GetGateOutputConnectionsForProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GateConnectionList, error) {
	out := new(GateConnectionList)
	err := c.cc.Invoke(ctx, CvGateController_GetGateOutputConnectionsForProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) ConnectCvInputToParameter(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_ConnectCvInputToParameter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) ConnectCvOutputFromParameter(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_ConnectCvOutputFromParameter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) ConnectGateInputToProcessor(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_ConnectGateInputToProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) ConnectGateOutputFromProcessor(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_ConnectGateOutputFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectCvInput(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectCvInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectCvOutput(ctx context.Context, in *CvConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectCvOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectGateInput(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectGateInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectGateOutput(ctx context.Context, in *GateConnection, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectGateOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectAllCvInputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectAllCvInputsFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectAllCvOutputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectAllCvOutputsFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectAllGateInputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectAllGateInputsFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cvGateControllerClient) DisconnectAllGateOutputsFromProcessor(ctx context.Context, in *ProcessorIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, CvGateController_DisconnectAllGateOutputsFromProcessor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CvGateControllerServer is the server API for CvGateController service.
// All implementations must embed UnimplementedCvGateControllerServer
// for forward compatibility
type CvGateControllerServer interface {
	GetCvInputChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetCvOutputChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetAllCvInputConnections(context.Context, *GenericVoidValue) (*CvConnectionList, error)
	GetAllCvOutputConnections(context.Context, *GenericVoidValue) (*CvConnectionList, error)
	GetAllGateInputConnections(context.Context, *GenericVoidValue) (*GateConnectionList, error)
	GetAllGateOutputConnections(context.Context, *GenericVoidValue) (*GateConnectionList, error)
	GetCvInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*CvConnectionList, error)
	GetCvOutputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*CvConnectionList, error)
	GetGateInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*GateConnectionList, error)
	GetGateOutputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*GateConnectionList, error)
	ConnectCvInputToParameter(context.Context, *CvConnection) (*GenericVoidValue, error)
	ConnectCvOutputFromParameter(context.Context, *CvConnection) (*GenericVoidValue, error)
	ConnectGateInputToProcessor(context.Context, *GateConnection) (*GenericVoidValue, error)
	ConnectGateOutputFromProcessor(context.Context, *GateConnection) (*GenericVoidValue, error)
	DisconnectCvInput(context.Context, *CvConnection) (*GenericVoidValue, error)
	DisconnectCvOutput(context.Context, *CvConnection) (*GenericVoidValue, error)
	DisconnectGateInput(context.Context, *GateConnection) (*GenericVoidValue, error)
	DisconnectGateOutput(context.Context, *GateConnection) (*GenericVoidValue, error)
	DisconnectAllCvInputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	DisconnectAllCvOutputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	DisconnectAllGateInputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	DisconnectAllGateOutputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error)
	mustEmbedUnimplementedCvGateControllerServer()
}

// UnimplementedCvGateControllerServer must be embedded to have forward compatible implementations.
type UnimplementedCvGateControllerServer struct {
}

func (UnimplementedCvGateControllerServer) GetCvInputChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCvInputChannelCount not implemented")
}
func (UnimplementedCvGateControllerServer) GetCvOutputChannelCount(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCvOutputChannelCount not implemented")
}
func (UnimplementedCvGateControllerServer) GetAllCvInputConnections(context.Context, *GenericVoidValue) (*CvConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCvInputConnections not implemented")
}
func (UnimplementedCvGateControllerServer) GetAllCvOutputConnections(context.Context, *GenericVoidValue) (*CvConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCvOutputConnections not implemented")
}
func (UnimplementedCvGateControllerServer) GetAllGateInputConnections(context.Context, *GenericVoidValue) (*GateConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGateInputConnections not implemented")
}
func (UnimplementedCvGateControllerServer) GetAllGateOutputConnections(context.Context, *GenericVoidValue) (*GateConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGateOutputConnections not implemented")
}
func (UnimplementedCvGateControllerServer) GetCvInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*CvConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCvInputConnectionsForProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) GetCvOutputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*CvConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCvOutputConnectionsForProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) GetGateInputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*GateConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGateInputConnectionsForProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) GetGateOutputConnectionsForProcessor(context.Context, *ProcessorIdentifier) (*GateConnectionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGateOutputConnectionsForProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) ConnectCvInputToParameter(context.Context, *CvConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectCvInputToParameter not implemented")
}
func (UnimplementedCvGateControllerServer) ConnectCvOutputFromParameter(context.Context, *CvConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectCvOutputFromParameter not implemented")
}
func (UnimplementedCvGateControllerServer) ConnectGateInputToProcessor(context.Context, *GateConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectGateInputToProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) ConnectGateOutputFromProcessor(context.Context, *GateConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectGateOutputFromProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectCvInput(context.Context, *CvConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectCvInput not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectCvOutput(context.Context, *CvConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectCvOutput not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectGateInput(context.Context, *GateConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectGateInput not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectGateOutput(context.Context, *GateConnection) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectGateOutput not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectAllCvInputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllCvInputsFromProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectAllCvOutputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllCvOutputsFromProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectAllGateInputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllGateInputsFromProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) DisconnectAllGateOutputsFromProcessor(context.Context, *ProcessorIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectAllGateOutputsFromProcessor not implemented")
}
func (UnimplementedCvGateControllerServer) mustEmbedUnimplementedCvGateControllerServer() {}

// UnsafeCvGateControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CvGateControllerServer will
// result in compilation errors.
type UnsafeCvGateControllerServer interface {
	mustEmbedUnimplementedCvGateControllerServer()
}

func RegisterCvGateControllerServer(s grpc.ServiceRegistrar, srv CvGateControllerServer) {
	s.RegisterService(&CvGateController_ServiceDesc, srv)
}

func _CvGateController_GetCvInputChannelCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetCvInputChannelCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetCvInputChannelCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetCvInputChannelCount(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetCvOutputChannelCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetCvOutputChannelCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetCvOutputChannelCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetCvOutputChannelCount(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetAllCvInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetAllCvInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetAllCvInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetAllCvInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetAllCvOutputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetAllCvOutputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetAllCvOutputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetAllCvOutputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetAllGateInputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetAllGateInputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetAllGateInputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetAllGateInputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetAllGateOutputConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetAllGateOutputConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetAllGateOutputConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetAllGateOutputConnections(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetCvInputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetCvInputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetCvInputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetCvInputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetCvOutputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetCvOutputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetCvOutputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetCvOutputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetGateInputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetGateInputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetGateInputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetGateInputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_GetGateOutputConnectionsForProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).GetGateOutputConnectionsForProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_GetGateOutputConnectionsForProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).GetGateOutputConnectionsForProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_ConnectCvInputToParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CvConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).ConnectCvInputToParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_ConnectCvInputToParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).ConnectCvInputToParameter(ctx, req.(*CvConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_ConnectCvOutputFromParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CvConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).ConnectCvOutputFromParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_ConnectCvOutputFromParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).ConnectCvOutputFromParameter(ctx, req.(*CvConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_ConnectGateInputToProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).ConnectGateInputToProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_ConnectGateInputToProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).ConnectGateInputToProcessor(ctx, req.(*GateConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_ConnectGateOutputFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).ConnectGateOutputFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_ConnectGateOutputFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).ConnectGateOutputFromProcessor(ctx, req.(*GateConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectCvInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CvConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectCvInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectCvInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectCvInput(ctx, req.(*CvConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectCvOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CvConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectCvOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectCvOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectCvOutput(ctx, req.(*CvConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectGateInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectGateInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectGateInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectGateInput(ctx, req.(*GateConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectGateOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GateConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectGateOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectGateOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectGateOutput(ctx, req.(*GateConnection))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectAllCvInputsFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectAllCvInputsFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectAllCvInputsFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectAllCvInputsFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectAllCvOutputsFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectAllCvOutputsFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectAllCvOutputsFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectAllCvOutputsFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectAllGateInputsFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectAllGateInputsFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectAllGateInputsFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectAllGateInputsFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _CvGateController_DisconnectAllGateOutputsFromProcessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessorIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CvGateControllerServer).DisconnectAllGateOutputsFromProcessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CvGateController_DisconnectAllGateOutputsFromProcessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CvGateControllerServer).DisconnectAllGateOutputsFromProcessor(ctx, req.(*ProcessorIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// CvGateController_ServiceDesc is the grpc.ServiceDesc for CvGateController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CvGateController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.CvGateController",
	HandlerType: (*CvGateControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCvInputChannelCount",
			Handler:    _CvGateController_GetCvInputChannelCount_Handler,
		},
		{
			MethodName: "GetCvOutputChannelCount",
			Handler:    _CvGateController_GetCvOutputChannelCount_Handler,
		},
		{
			MethodName: "GetAllCvInputConnections",
			Handler:    _CvGateController_GetAllCvInputConnections_Handler,
		},
		{
			MethodName: "GetAllCvOutputConnections",
			Handler:    _CvGateController_GetAllCvOutputConnections_Handler,
		},
		{
			MethodName: "GetAllGateInputConnections",
			Handler:    _CvGateController_GetAllGateInputConnections_Handler,
		},
		{
			MethodName: "GetAllGateOutputConnections",
			Handler:    _CvGateController_GetAllGateOutputConnections_Handler,
		},
		{
			MethodName: "GetCvInputConnectionsForProcessor",
			Handler:    _CvGateController_GetCvInputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "GetCvOutputConnectionsForProcessor",
			Handler:    _CvGateController_GetCvOutputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "GetGateInputConnectionsForProcessor",
			Handler:    _CvGateController_GetGateInputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "GetGateOutputConnectionsForProcessor",
			Handler:    _CvGateController_GetGateOutputConnectionsForProcessor_Handler,
		},
		{
			MethodName: "ConnectCvInputToParameter",
			Handler:    _CvGateController_ConnectCvInputToParameter_Handler,
		},
		{
			MethodName: "ConnectCvOutputFromParameter",
			Handler:    _CvGateController_ConnectCvOutputFromParameter_Handler,
		},
		{
			MethodName: "ConnectGateInputToProcessor",
			Handler:    _CvGateController_ConnectGateInputToProcessor_Handler,
		},
		{
			MethodName: "ConnectGateOutputFromProcessor",
			Handler:    _CvGateController_ConnectGateOutputFromProcessor_Handler,
		},
		{
			MethodName: "DisconnectCvInput",
			Handler:    _CvGateController_DisconnectCvInput_Handler,
		},
		{
			MethodName: "DisconnectCvOutput",
			Handler:    _CvGateController_DisconnectCvOutput_Handler,
		},
		{
			MethodName: "DisconnectGateInput",
			Handler:    _CvGateController_DisconnectGateInput_Handler,
		},
		{
			MethodName: "DisconnectGateOutput",
			Handler:    _CvGateController_DisconnectGateOutput_Handler,
		},
		{
			MethodName: "DisconnectAllCvInputsFromProcessor",
			Handler:    _CvGateController_DisconnectAllCvInputsFromProcessor_Handler,
		},
		{
			MethodName: "DisconnectAllCvOutputsFromProcessor",
			Handler:    _CvGateController_DisconnectAllCvOutputsFromProcessor_Handler,
		},
		{
			MethodName: "DisconnectAllGateInputsFromProcessor",
			Handler:    _CvGateController_DisconnectAllGateInputsFromProcessor_Handler,
		},
		{
			MethodName: "DisconnectAllGateOutputsFromProcessor",
			Handler:    _CvGateController_DisconnectAllGateOutputsFromProcessor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	OscController_GetSendIP_FullMethodName                  = "/sushi_rpc.OscController/GetSendIP"
	OscController_GetSendPort_FullMethodName                = "/sushi_rpc.OscController/GetSendPort"
	OscController_GetReceivePort_FullMethodName             = "/sushi_rpc.OscController/GetReceivePort"
	OscController_GetEnabledParameterOutputs_FullMethodName = "/sushi_rpc.OscController/GetEnabledParameterOutputs"
	OscController_EnableOutputForParameter_FullMethodName   = "/sushi_rpc.OscController/EnableOutputForParameter"
	OscController_DisableOutputForParameter_FullMethodName  = "/sushi_rpc.OscController/DisableOutputForParameter"
	OscController_EnableAllOutput_FullMethodName            = "/sushi_rpc.OscController/EnableAllOutput"
	OscController_DisableAllOutput_FullMethodName           = "/sushi_rpc.OscController/DisableAllOutput"
)

// OscControllerClient is the client API for OscController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OscControllerClient interface {
	GetSendIP(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericStringValue, error)
	GetSendPort(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetReceivePort(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error)
	GetEnabledParameterOutputs(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*OscParameterOutputList, error)
	EnableOutputForParameter(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisableOutputForParameter(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error)
	EnableAllOutput(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
	DisableAllOutput(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type oscControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewOscControllerClient(cc grpc.ClientConnInterface) OscControllerClient {
	return &oscControllerClient{cc}
}

func (c *oscControllerClient) GetSendIP(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericStringValue, error) {
	out := new(GenericStringValue)
	err := c.cc.Invoke(ctx, OscController_GetSendIP_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) GetSendPort(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, OscController_GetSendPort_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) GetReceivePort(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericIntValue, error) {
	out := new(GenericIntValue)
	err := c.cc.Invoke(ctx, OscController_GetReceivePort_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) GetEnabledParameterOutputs(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*OscParameterOutputList, error) {
	out := new(OscParameterOutputList)
	err := c.cc.Invoke(ctx, OscController_GetEnabledParameterOutputs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) EnableOutputForParameter(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, OscController_EnableOutputForParameter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) DisableOutputForParameter(ctx context.Context, in *ParameterIdentifier, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, OscController_DisableOutputForParameter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) EnableAllOutput(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, OscController_EnableAllOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oscControllerClient) DisableAllOutput(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, OscController_DisableAllOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OscControllerServer is the server API for OscController service.
// All implementations must embed UnimplementedOscControllerServer
// for forward compatibility
type OscControllerServer interface {
	GetSendIP(context.Context, *GenericVoidValue) (*GenericStringValue, error)
	GetSendPort(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetReceivePort(context.Context, *GenericVoidValue) (*GenericIntValue, error)
	GetEnabledParameterOutputs(context.Context, *GenericVoidValue) (*OscParameterOutputList, error)
	EnableOutputForParameter(context.Context, *ParameterIdentifier) (*GenericVoidValue, error)
	DisableOutputForParameter(context.Context, *ParameterIdentifier) (*GenericVoidValue, error)
	EnableAllOutput(context.Context, *GenericVoidValue) (*GenericVoidValue, error)
	DisableAllOutput(context.Context, *GenericVoidValue) (*GenericVoidValue, error)
	mustEmbedUnimplementedOscControllerServer()
}

// UnimplementedOscControllerServer must be embedded to have forward compatible implementations.
type UnimplementedOscControllerServer struct {
}

func (UnimplementedOscControllerServer) GetSendIP(context.Context, *GenericVoidValue) (*GenericStringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSendIP not implemented")
}
func (UnimplementedOscControllerServer) GetSendPort(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSendPort not implemented")
}
func (UnimplementedOscControllerServer) GetReceivePort(context.Context, *GenericVoidValue) (*GenericIntValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReceivePort not implemented")
}
func (UnimplementedOscControllerServer) GetEnabledParameterOutputs(context.Context, *GenericVoidValue) (*OscParameterOutputList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEnabledParameterOutputs not implemented")
}
func (UnimplementedOscControllerServer) EnableOutputForParameter(context.Context, *ParameterIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableOutputForParameter not implemented")
}
func (UnimplementedOscControllerServer) DisableOutputForParameter(context.Context, *ParameterIdentifier) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableOutputForParameter not implemented")
}
func (UnimplementedOscControllerServer) EnableAllOutput(context.Context, *GenericVoidValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableAllOutput not implemented")
}
func (UnimplementedOscControllerServer) DisableAllOutput(context.Context, *GenericVoidValue) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableAllOutput not implemented")
}
func (UnimplementedOscControllerServer) mustEmbedUnimplementedOscControllerServer() {}

// UnsafeOscControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OscControllerServer will
// result in compilation errors.
type UnsafeOscControllerServer interface {
	mustEmbedUnimplementedOscControllerServer()
}

func RegisterOscControllerServer(s grpc.ServiceRegistrar, srv OscControllerServer) {
	s.RegisterService(&OscController_ServiceDesc, srv)
}

func _OscController_GetSendIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).GetSendIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_GetSendIP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).GetSendIP(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_GetSendPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).GetSendPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_GetSendPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).GetSendPort(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_GetReceivePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).GetReceivePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_GetReceivePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).GetReceivePort(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_GetEnabledParameterOutputs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).GetEnabledParameterOutputs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_GetEnabledParameterOutputs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).GetEnabledParameterOutputs(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_EnableOutputForParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).EnableOutputForParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_EnableOutputForParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).EnableOutputForParameter(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_DisableOutputForParameter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParameterIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).DisableOutputForParameter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_DisableOutputForParameter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).DisableOutputForParameter(ctx, req.(*ParameterIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_EnableAllOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).EnableAllOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_EnableAllOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).EnableAllOutput(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _OscController_DisableAllOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OscControllerServer).DisableAllOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OscController_DisableAllOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OscControllerServer).DisableAllOutput(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

// OscController_ServiceDesc is the grpc.ServiceDesc for OscController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OscController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.OscController",
	HandlerType: (*OscControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSendIP",
			Handler:    _OscController_GetSendIP_Handler,
		},
		{
			MethodName: "GetSendPort",
			Handler:    _OscController_GetSendPort_Handler,
		},
		{
			MethodName: "GetReceivePort",
			Handler:    _OscController_GetReceivePort_Handler,
		},
		{
			MethodName: "GetEnabledParameterOutputs",
			Handler:    _OscController_GetEnabledParameterOutputs_Handler,
		},
		{
			MethodName: "EnableOutputForParameter",
			Handler:    _OscController_EnableOutputForParameter_Handler,
		},
		{
			MethodName: "DisableOutputForParameter",
			Handler:    _OscController_DisableOutputForParameter_Handler,
		},
		{
			MethodName: "EnableAllOutput",
			Handler:    _OscController_EnableAllOutput_Handler,
		},
		{
			MethodName: "DisableAllOutput",
			Handler:    _OscController_DisableAllOutput_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	SessionController_SaveSession_FullMethodName    = "/sushi_rpc.SessionController/SaveSession"
	SessionController_RestoreSession_FullMethodName = "/sushi_rpc.SessionController/RestoreSession"
)

// SessionControllerClient is the client API for SessionController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionControllerClient interface {
	SaveSession(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SessionState, error)
	RestoreSession(ctx context.Context, in *SessionState, opts ...grpc.CallOption) (*GenericVoidValue, error)
}

type sessionControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionControllerClient(cc grpc.ClientConnInterface) SessionControllerClient {
	return &sessionControllerClient{cc}
}

func (c *sessionControllerClient) SaveSession(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (*SessionState, error) {
	out := new(SessionState)
	err := c.cc.Invoke(ctx, SessionController_SaveSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionControllerClient) RestoreSession(ctx context.Context, in *SessionState, opts ...grpc.CallOption) (*GenericVoidValue, error) {
	out := new(GenericVoidValue)
	err := c.cc.Invoke(ctx, SessionController_RestoreSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionControllerServer is the server API for SessionController service.
// All implementations must embed UnimplementedSessionControllerServer
// for forward compatibility
type SessionControllerServer interface {
	SaveSession(context.Context, *GenericVoidValue) (*SessionState, error)
	RestoreSession(context.Context, *SessionState) (*GenericVoidValue, error)
	mustEmbedUnimplementedSessionControllerServer()
}

// UnimplementedSessionControllerServer must be embedded to have forward compatible implementations.
type UnimplementedSessionControllerServer struct {
}

func (UnimplementedSessionControllerServer) SaveSession(context.Context, *GenericVoidValue) (*SessionState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveSession not implemented")
}
func (UnimplementedSessionControllerServer) RestoreSession(context.Context, *SessionState) (*GenericVoidValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreSession not implemented")
}
func (UnimplementedSessionControllerServer) mustEmbedUnimplementedSessionControllerServer() {}

// UnsafeSessionControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionControllerServer will
// result in compilation errors.
type UnsafeSessionControllerServer interface {
	mustEmbedUnimplementedSessionControllerServer()
}

func RegisterSessionControllerServer(s grpc.ServiceRegistrar, srv SessionControllerServer) {
	s.RegisterService(&SessionController_ServiceDesc, srv)
}

func _SessionController_SaveSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenericVoidValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionControllerServer).SaveSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionController_SaveSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionControllerServer).SaveSession(ctx, req.(*GenericVoidValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionController_RestoreSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionControllerServer).RestoreSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionController_RestoreSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionControllerServer).RestoreSession(ctx, req.(*SessionState))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionController_ServiceDesc is the grpc.ServiceDesc for SessionController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.SessionController",
	HandlerType: (*SessionControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveSession",
			Handler:    _SessionController_SaveSession_Handler,
		},
		{
			MethodName: "RestoreSession",
			Handler:    _SessionController_RestoreSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sushi_rpc.proto",
}

const (
	NotificationController_SubscribeToTransportChanges_FullMethodName       = "/sushi_rpc.NotificationController/SubscribeToTransportChanges"
	NotificationController_SubscribeToEngineCpuTimingUpdates_FullMethodName = "/sushi_rpc.NotificationController/SubscribeToEngineCpuTimingUpdates"
	NotificationController_SubscribeToTrackChanges_FullMethodName           = "/sushi_rpc.NotificationController/SubscribeToTrackChanges"
	NotificationController_SubscribeToProcessorChanges_FullMethodName       = "/sushi_rpc.NotificationController/SubscribeToProcessorChanges"
	NotificationController_SubscribeToParameterUpdates_FullMethodName       = "/sushi_rpc.NotificationController/SubscribeToParameterUpdates"
	NotificationController_SubscribeToPropertyUpdates_FullMethodName        = "/sushi_rpc.NotificationController/SubscribeToPropertyUpdates"
)

// NotificationControllerClient is the client API for NotificationController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationControllerClient interface {
	SubscribeToTransportChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToTransportChangesClient, error)
	SubscribeToEngineCpuTimingUpdates(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToEngineCpuTimingUpdatesClient, error)
	SubscribeToTrackChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToTrackChangesClient, error)
	SubscribeToProcessorChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToProcessorChangesClient, error)
	SubscribeToParameterUpdates(ctx context.Context, in *ParameterNotificationBlocklist, opts ...grpc.CallOption) (NotificationController_SubscribeToParameterUpdatesClient, error)
	SubscribeToPropertyUpdates(ctx context.Context, in *PropertyNotificationBlocklist, opts ...grpc.CallOption) (NotificationController_SubscribeToPropertyUpdatesClient, error)
}

type notificationControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationControllerClient(cc grpc.ClientConnInterface) NotificationControllerClient {
	return &notificationControllerClient{cc}
}

func (c *notificationControllerClient) SubscribeToTransportChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToTransportChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[0], NotificationController_SubscribeToTransportChanges_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToTransportChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToTransportChangesClient interface {
	Recv() (*TransportUpdate, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToTransportChangesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToTransportChangesClient) Recv() (*TransportUpdate, error) {
	m := new(TransportUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notificationControllerClient) SubscribeToEngineCpuTimingUpdates(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToEngineCpuTimingUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[1], NotificationController_SubscribeToEngineCpuTimingUpdates_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToEngineCpuTimingUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToEngineCpuTimingUpdatesClient interface {
	Recv() (*CpuTimings, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToEngineCpuTimingUpdatesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToEngineCpuTimingUpdatesClient) Recv() (*CpuTimings, error) {
	m := new(CpuTimings)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notificationControllerClient) SubscribeToTrackChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToTrackChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[2], NotificationController_SubscribeToTrackChanges_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToTrackChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToTrackChangesClient interface {
	Recv() (*TrackUpdate, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToTrackChangesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToTrackChangesClient) Recv() (*TrackUpdate, error) {
	m := new(TrackUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notificationControllerClient) SubscribeToProcessorChanges(ctx context.Context, in *GenericVoidValue, opts ...grpc.CallOption) (NotificationController_SubscribeToProcessorChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[3], NotificationController_SubscribeToProcessorChanges_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToProcessorChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToProcessorChangesClient interface {
	Recv() (*ProcessorUpdate, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToProcessorChangesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToProcessorChangesClient) Recv() (*ProcessorUpdate, error) {
	m := new(ProcessorUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notificationControllerClient) SubscribeToParameterUpdates(ctx context.Context, in *ParameterNotificationBlocklist, opts ...grpc.CallOption) (NotificationController_SubscribeToParameterUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[4], NotificationController_SubscribeToParameterUpdates_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToParameterUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToParameterUpdatesClient interface {
	Recv() (*ParameterUpdate, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToParameterUpdatesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToParameterUpdatesClient) Recv() (*ParameterUpdate, error) {
	m := new(ParameterUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *notificationControllerClient) SubscribeToPropertyUpdates(ctx context.Context, in *PropertyNotificationBlocklist, opts ...grpc.CallOption) (NotificationController_SubscribeToPropertyUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NotificationController_ServiceDesc.Streams[5], NotificationController_SubscribeToPropertyUpdates_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &notificationControllerSubscribeToPropertyUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NotificationController_SubscribeToPropertyUpdatesClient interface {
	Recv() (*PropertyValue, error)
	grpc.ClientStream
}

type notificationControllerSubscribeToPropertyUpdatesClient struct {
	grpc.ClientStream
}

func (x *notificationControllerSubscribeToPropertyUpdatesClient) Recv() (*PropertyValue, error) {
	m := new(PropertyValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NotificationControllerServer is the server API for NotificationController service.
// All implementations must embed UnimplementedNotificationControllerServer
// for forward compatibility
type NotificationControllerServer interface {
	SubscribeToTransportChanges(*GenericVoidValue, NotificationController_SubscribeToTransportChangesServer) error
	SubscribeToEngineCpuTimingUpdates(*GenericVoidValue, NotificationController_SubscribeToEngineCpuTimingUpdatesServer) error
	SubscribeToTrackChanges(*GenericVoidValue, NotificationController_SubscribeToTrackChangesServer) error
	SubscribeToProcessorChanges(*GenericVoidValue, NotificationController_SubscribeToProcessorChangesServer) error
	SubscribeToParameterUpdates(*ParameterNotificationBlocklist, NotificationController_SubscribeToParameterUpdatesServer) error
	SubscribeToPropertyUpdates(*PropertyNotificationBlocklist, NotificationController_SubscribeToPropertyUpdatesServer) error
	mustEmbedUnimplementedNotificationControllerServer()
}

// UnimplementedNotificationControllerServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationControllerServer struct {
}

func (UnimplementedNotificationControllerServer) SubscribeToTransportChanges(*GenericVoidValue, NotificationController_SubscribeToTransportChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToTransportChanges not implemented")
}
func (UnimplementedNotificationControllerServer) SubscribeToEngineCpuTimingUpdates(*GenericVoidValue, NotificationController_SubscribeToEngineCpuTimingUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToEngineCpuTimingUpdates not implemented")
}
func (UnimplementedNotificationControllerServer) SubscribeToTrackChanges(*GenericVoidValue, NotificationController_SubscribeToTrackChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToTrackChanges not implemented")
}
func (UnimplementedNotificationControllerServer) SubscribeToProcessorChanges(*GenericVoidValue, NotificationController_SubscribeToProcessorChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToProcessorChanges not implemented")
}
func (UnimplementedNotificationControllerServer) SubscribeToParameterUpdates(*ParameterNotificationBlocklist, NotificationController_SubscribeToParameterUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToParameterUpdates not implemented")
}
func (UnimplementedNotificationControllerServer) SubscribeToPropertyUpdates(*PropertyNotificationBlocklist, NotificationController_SubscribeToPropertyUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToPropertyUpdates not implemented")
}
func (UnimplementedNotificationControllerServer) mustEmbedUnimplementedNotificationControllerServer() {
}

// UnsafeNotificationControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationControllerServer will
// result in compilation errors.
type UnsafeNotificationControllerServer interface {
	mustEmbedUnimplementedNotificationControllerServer()
}

func RegisterNotificationControllerServer(s grpc.ServiceRegistrar, srv NotificationControllerServer) {
	s.RegisterService(&NotificationController_ServiceDesc, srv)
}

func _NotificationController_SubscribeToTransportChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenericVoidValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToTransportChanges(m, &notificationControllerSubscribeToTransportChangesServer{stream})
}

type NotificationController_SubscribeToTransportChangesServer interface {
	Send(*TransportUpdate) error
	grpc.ServerStream
}

type notificationControllerSubscribeToTransportChangesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToTransportChangesServer) Send(m *TransportUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _NotificationController_SubscribeToEngineCpuTimingUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenericVoidValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToEngineCpuTimingUpdates(m, &notificationControllerSubscribeToEngineCpuTimingUpdatesServer{stream})
}

type NotificationController_SubscribeToEngineCpuTimingUpdatesServer interface {
	Send(*CpuTimings) error
	grpc.ServerStream
}

type notificationControllerSubscribeToEngineCpuTimingUpdatesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToEngineCpuTimingUpdatesServer) Send(m *CpuTimings) error {
	return x.ServerStream.SendMsg(m)
}

func _NotificationController_SubscribeToTrackChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenericVoidValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToTrackChanges(m, &notificationControllerSubscribeToTrackChangesServer{stream})
}

type NotificationController_SubscribeToTrackChangesServer interface {
	Send(*TrackUpdate) error
	grpc.ServerStream
}

type notificationControllerSubscribeToTrackChangesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToTrackChangesServer) Send(m *TrackUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _NotificationController_SubscribeToProcessorChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GenericVoidValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToProcessorChanges(m, &notificationControllerSubscribeToProcessorChangesServer{stream})
}

type NotificationController_SubscribeToProcessorChangesServer interface {
	Send(*ProcessorUpdate) error
	grpc.ServerStream
}

type notificationControllerSubscribeToProcessorChangesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToProcessorChangesServer) Send(m *ProcessorUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _NotificationController_SubscribeToParameterUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ParameterNotificationBlocklist)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToParameterUpdates(m, &notificationControllerSubscribeToParameterUpdatesServer{stream})
}

type NotificationController_SubscribeToParameterUpdatesServer interface {
	Send(*ParameterUpdate) error
	grpc.ServerStream
}

type notificationControllerSubscribeToParameterUpdatesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToParameterUpdatesServer) Send(m *ParameterUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _NotificationController_SubscribeToPropertyUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PropertyNotificationBlocklist)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NotificationControllerServer).SubscribeToPropertyUpdates(m, &notificationControllerSubscribeToPropertyUpdatesServer{stream})
}

type NotificationController_SubscribeToPropertyUpdatesServer interface {
	Send(*PropertyValue) error
	grpc.ServerStream
}

type notificationControllerSubscribeToPropertyUpdatesServer struct {
	grpc.ServerStream
}

func (x *notificationControllerSubscribeToPropertyUpdatesServer) Send(m *PropertyValue) error {
	return x.ServerStream.SendMsg(m)
}

// NotificationController_ServiceDesc is the grpc.ServiceDesc for NotificationController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sushi_rpc.NotificationController",
	HandlerType: (*NotificationControllerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToTransportChanges",
			Handler:       _NotificationController_SubscribeToTransportChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToEngineCpuTimingUpdates",
			Handler:       _NotificationController_SubscribeToEngineCpuTimingUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToTrackChanges",
			Handler:       _NotificationController_SubscribeToTrackChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToProcessorChanges",
			Handler:       _NotificationController_SubscribeToProcessorChanges_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToParameterUpdates",
			Handler:       _NotificationController_SubscribeToParameterUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToPropertyUpdates",
			Handler:       _NotificationController_SubscribeToPropertyUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sushi_rpc.proto",
}
